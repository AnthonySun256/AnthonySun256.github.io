<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《数字图像处理》第三章笔记</title>
      <link href="/2020/02/shu-zi-tu-xiang-chu-li-di-san-zhang-bi-ji/"/>
      <url>/2020/02/shu-zi-tu-xiang-chu-li-di-san-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章主要讲的是<strong>空间域</strong>的操作（即图像本身）</p></blockquote><p>本章主要讨论形如$g(x,y) = T[f(x,y)]$的灰度变换和空间滤波</p><p>上面的公式也可以写成更一般的形式$$s = T(r)$$</p><ul><li><p>$s、r$分别表示输出图像和源图像</p></li><li><p>操作$T$可以是对邻域的操作（比如对图像进行模糊操作）</p></li></ul><p>灰度变换和空间滤波可用于<strong>图像增强</strong></p><p>灰度变换可以是一个简单的映射（比如$T$代表查表操作，源图像每一个灰度值在表里头都有一个对应的灰度值作为输出）</p><h1 id="基本灰度变换函数"><a href="#基本灰度变换函数" class="headerlink" title="基本灰度变换函数"></a>基本灰度变换函数</h1><h2 id="图像反转"><a href="#图像反转" class="headerlink" title="图像反转"></a>图像反转</h2><p>$s = 255 - r$，就是一个8bit灰度图像的反转方法，可以做出来底片的效果</p><h2 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h2><p>$$s = c\log{(1+r)}, r\ge0,c=const$$</p><p>可以把灰度值中范围较窄<strong>低灰度值</strong>范围映射到一个范围较宽的灰度值范围，或者把范围较宽的<strong>高灰度值</strong>范围压缩为范围较窄的灰度值范围</p><ul><li>用来拓展图片中<strong>暗的像素</strong>（让本来暗的地方亮一些），同时压缩高灰度</li><li><strong>反对数函数</strong>作用效果正好相反</li><li>以上结论可以看对数函数图像得知</li><li>对数变换可用于傅里叶频谱的校正（傅里叶频谱输出值很大($10^6$级别)会丢失灰度值小的像素信息（因为只用8bit存储），但取对数后可以压缩为个位数防止信息丢失过多）</li></ul><h2 id="幂律（伽马）变换"><a href="#幂律（伽马）变换" class="headerlink" title="幂律（伽马）变换"></a>幂律（伽马）变换</h2><p>$$s = cr^\gamma$$</p><ul><li>$\gamma &gt;1$和$\gamma &lt;1$时的效果<strong>完全相反</strong></li><li>用于伽马矫正，压缩一些灰度范围，扩展一些灰度范围</li><li>可以增强对比度</li><li>增强暗部，或者减少亮部</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数字图像处理》第二章笔记</title>
      <link href="/2020/02/shu-zi-tu-xiang-chu-li-di-er-zhang-bi-ji/"/>
      <url>/2020/02/shu-zi-tu-xiang-chu-li-di-er-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是《数字图像处理（第三版）》的学习笔记，方便日后回忆和查看</p><p>对于一些难懂的知识加入了一些自己的理解和其他讲的比较明白的博客的链接</p><h1 id="关于人眼"><a href="#关于人眼" class="headerlink" title="关于人眼"></a>关于人眼</h1><ul><li>人眼的的视觉系统不是工作在全频段的，每次我们看不同亮度的物体都需要眼睛调节灵敏度。这叫做<strong>亮度适应现象</strong>，同一时间眼睛能够辨别的亮度级别很小，对于当前给定的亮度人眼的灵敏度级别称作<strong>亮度适应级别</strong></li></ul><h1 id="图像的获取"><a href="#图像的获取" class="headerlink" title="图像的获取"></a>图像的获取</h1><p>常见的图像传感器的排列方式有以下几种</p><ul><li>成一维的条状平面传感器，给该传感器加上一个垂直的传动带，就可以一行一行的读取数据</li><li>只有一块传感器，通过X，Y方向的位移获取数据<ul><li>典型的是传感器放在一根杆上，杆连接在一个圆柱桶上（类似于滑动变阻器，只不过把滑头变成单独一个传感器），桶上贴着胶片。每次桶先转动然后传感器滑动读取x方向数据，以此来读取一行</li></ul></li><li>核磁共振那样的圆筒，扫描物体的断层信息，需要配合专门的算法生成图片</li><li>传感器阵列，平铺在平面上，比如摄像机的CCD阵列</li><li>传感器获取的主要就是电磁信号<ul><li>这些信号有的是被测物体反射回来的（比如摄像机拍摄的）</li><li>有些信号是穿过被观测物体打在传感器上的（比如X光片）</li></ul></li><li>传感器输出信号强度大小与照射到传感器上电磁信号的强度成正比</li></ul><h1 id="图像模型"><a href="#图像模型" class="headerlink" title="图像模型"></a>图像模型</h1><ul><li><p>现在大家都使用$f(x,y)$这样的二维函数来表示图像。</p></li><li><p>在空间坐标$(x,y)$处$f$的值或幅度是一个正的标量，其物理意义由图像源决定。</p><ul><li>如果图像由物理过程产生，其亮度值正比于物理源（如电磁波）所辐射的能量<ul><li>所以 $0&lt;f(x,y)&lt;\infty$ （一定是非零有限的）</li></ul></li></ul></li><li><p>函数$f(x,y)$可由两个分量来表征</p><ul><li><p>观察场景的里光源照射总量</p></li><li><p>场景中物体所反射的光照总量</p></li><li><p>这两个量被称为<strong>入射分量</strong>和<strong>反射分量</strong>，而且$f(x,y) = i(x,y)r(x,y)$</p><ul><li><p>分别表示为$i(x,y)$和$r(x,y)$</p><ul><li><p>$0&lt;i(x,y)&lt;\infty$</p></li><li><p>$0&lt;r(x,y)&lt;1$，由于是反射分量，0表示全吸收，1表示全反射，这个取决于被成像物体的性质</p></li><li><blockquote><p>平均来讲，晴朗白天太阳照在地面大概产生$90,000 lm/m^{2}$</p><p>有云的白天可能就下降到$10,000lm/m^2$</p><p>晴朗的夜晚，满月时照度约为$0.1lm/m^2$</p><p>商用办公室典型照度约为$1000lm/m^2$</p><p>下面是$r(x,y)$的典型值</p><p>黑天鹅绒为$0.01$</p><p>不锈钢为$0.65$</p><p>白墙为$0.80$</p><p>镀银金属为$0.90$</p><p>雪为$0.93$</p></blockquote></li></ul></li></ul></li><li><p>对于上面这条，如果是类似X光这样的透射，应该用<strong>透射系数</strong>代替<strong>反射函数</strong>$r(x,y)$</p></li></ul></li><li><p>令单色图像在任何坐标$(x_{0},y_{0})$处<strong>强度（灰度）</strong>（强度和灰度含义相同）表示为$$\ell = f(x_0,y_0)$$</p><ul><li>因为$f(x,y) = i(x,y)r(x,y)$里面$i,r$都有范围，所以$L_{min}\le\ell\le L_{max}$</li><li>理论上只要求$L_{min}$为正，$L_{max}$为有限值。<ul><li>实际上，因为$L_{min} = i_{min}r_{min}$和$L_{max} = i_{max}r_{max}$ 根据之前说的办公室平均照度$i$和反射值$r$，我们希望$L_{min}\approx 10$和$L_{max}\approx 1000$作为室内没有附加照明时的典型范围</li><li>区间$[L_{min},L_{max}]$称为灰度级（或者强度级）。实际情况下通常令该区间为$[0,L-1]$<ul><li>其中$\ell = 0$为灰色</li><li>$\ell = L-1$<strong>在灰度级中</strong>为白色</li><li>所有中间值是 从黑色到白色之间变化的灰度色调</li></ul></li></ul></li></ul></li></ul><h1 id="图像的取样和量化"><a href="#图像的取样和量化" class="headerlink" title="图像的取样和量化"></a>图像的取样和量化</h1><ul><li>取样需要离散化图片的灰度值和图像上连续的灰度值函数（书P30图2.1.6形象说明）<ul><li>每个点的灰度值按照就近原则对应到不同的灰度级（例子给了八个级别）</li></ul></li></ul><h1 id="图像的表示"><a href="#图像的表示" class="headerlink" title="图像的表示"></a>图像的表示</h1><ul><li>离散图像在任一$(x,y)$处的值记为$f(x,y)$<ul><li>$x = 0,1,2,…,M-1$，$y=0,1,2,…,N-1$</li><li>$f(0,1)$表示<strong>第一行第二个</strong>像素的值</li></ul></li><li>二维图像可由$x,y$轴和另外的$z$轴（高低代表灰度值）的三维图像表示（太复杂了，通常不用）</li><li>用显示器或打印机，每个像素点的灰度值与该点的$f$值成正比</li><li><strong>把$f(x,y)$表示为数值阵列</strong></li><li>使用矩阵表示数字图像及其像素$A = $ 一个矩阵<ul><li>$a_{ij} = f(x=i,y=j) = f(i,j)$</li><li>灰度级数通常取2的整数次幂，$L=2^k$ </li></ul></li><li>动态范围：一幅图片可能不会占用全部256 ($2^8$)级灰度，图片里面所有像素跨越的灰度值称为动态范围<ul><li>比如一幅图片很暗，它可能的动态范围可能只有 $[0,100]$ ，而不是全部$[0,256]$（256是因为现在主流每个像素用8bit表示，可以表示256级灰度）</li><li>上限取决于饱和度，下限取决于噪声</li></ul></li><li>对比度：图像中最高级灰度和最低级灰度的差成为对比度<ul><li>动态范围高对比度高，反之低动态范围的图片看起来很沉闷</li></ul></li><li>存储一幅图像所需bit $b = M<em>N</em>k$ （长乘宽乘用几个比特表示灰度级）</li></ul><h1 id="空间和灰度分辨率"><a href="#空间和灰度分辨率" class="headerlink" title="空间和灰度分辨率"></a>空间和灰度分辨率</h1><ul><li><p><strong>空间分辨率</strong>用来度量图像中最小可辨细节</p><ul><li>通常用单位距离的线对数和单位距离的点数（像素数）</li><li>美国的印刷品使用的单位：dpi 表示每英寸的点数</li><li><strong>空间分辨率</strong>需要对空间的<strong>单位</strong>有定义才有实际意义（不然单位距离到底是多少）</li></ul></li><li><p>不知道图像包含的空间维数，谈论图像的分辨率（比如说某图是1024*1024像素）是没有意义的。尺寸本身只用在比较图像容量时</p><ul><li>可以说拍摄情况相同时候高清相机比普通相机分辨细节的能力高</li></ul></li><li><p><strong>灰度分辨率</strong>指在灰度级中可分辨的最小变化</p><ul><li>指的是用于量化灰度的比特数，比如256级的图像具有8bit的灰度分辨率</li></ul></li><li><p>减少k值（灰度分辨率）会提高图像对比度</p><ul><li><blockquote><p>百度的解释：</p><p>对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围的大小就是所说的对比度的大小.<br>减少灰度一级,就是说,灰的再暗一些的意思,这样图像的层次与艳丽会提高一档.<br>方便的话,可以用photoshop 里的色阶,就一目了然了.</p></blockquote></li></ul></li></ul><h1 id="图像内插"><a href="#图像内插" class="headerlink" title="图像内插"></a>图像内插</h1><blockquote><p>内插是放大、收缩、旋转、几何校正等任务的基本工具</p><p>本质上内插是用已知的数据去估计未知的数据</p></blockquote><h2 id="放大的插值方法"><a href="#放大的插值方法" class="headerlink" title="放大的插值方法"></a>放大的插值方法</h2><ul><li><p>最邻近内插（P37）</p></li><li><p>双线性内插</p><ul><li><p>令$(x,y)$为我们想要赋值的位置，令$v(x,y)$表示灰度值。</p></li><li><p>$v(x,y) = ax+by+cxy+d$  </p></li><li><blockquote><p>由于具有$xy$项，这其实不是一种线性内插方法，但不知道为啥名字里有线性二字</p></blockquote></li><li><p>式子中的四个系数可用由点$(x,y)$的四个最邻近点写出的未知方程确定</p></li></ul></li><li><p>双三次内插法，包括16个最邻近点（最常用）</p></li></ul><h1 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h1><ul><li><p>相邻像素</p><ul><li>上下左右四个像素称为4邻域，用$N_4(P)$表示。</li><li>左上右上左下右下四个像素用$N_D(P)$表示</li><li>八个相邻像素称为8邻域，用$N_8(P)$表示</li></ul></li><li><p>邻接、连接和连通，这篇<a href="https://www.cnblogs.com/SilentCode/p/5352860.html" target="_blank" rel="noopener">博客</a>有讲</p><ul><li>闭合通路（连通的起点和终点一样）</li><li>连通集：只有一个连通分量的集合<strong>也可称作区域</strong></li></ul></li><li><p>如果两个区域（$R_i和R_j$）可以形成一个<strong>连通集</strong>，他们叫做<strong>邻接区域</strong>，不邻接的区域称为不连接区域</p><ul><li>四邻接：上下左右四个点</li><li>八邻接：上下左右加上四个角，这样的一圈（<strong>所以属于4邻接的一定属于8邻接</strong>，反过来不行）</li><li>M邻接：同时存在八邻接和四邻接时候优先用四邻接（<strong>消除二义性</strong>）</li><li><a href="https://www.cnblogs.com/qinguoyi/p/7601178.html" target="_blank" rel="noopener">m邻接 </a></li></ul></li><li><p>两点间距离，设两点$P(x,y)$和$Q(s,t)$</p><ul><li>欧氏距离$D_e = \sqrt{(x-s)^2+(y-t)^2}$</li><li>曼哈顿距离（城市街区距离）$D_4 = |x-s|+|y-t|$，$D_4 = 1$时为像素的四邻域</li><li>棋盘距离 $D_8 = max(|x-s|,|y-t|)$，$D_8 = 1$时为像素的八邻域</li><li>$D_4$和$D_8$距离与任何通路<strong>无关</strong>这俩距离只与坐标有关</li><li>$D_m$距离用两点间的最短通路定义（按照m邻接方式计算）</li></ul></li></ul><h1 id="线性操作与非线性操作"><a href="#线性操作与非线性操作" class="headerlink" title="线性操作与非线性操作"></a>线性操作与非线性操作</h1><ul><li>线性操作：给定一个算子$H$，应用于特定的输入图像$f(x,y)$，输出图像$g(x,y)$<ul><li>线性算子$H$满足$H[a_if_i(x,y)+a_jf_j(x,y)] = a_iH[f_i(x,.y)]+a_jf_j(x,y) = a_ig_i(x,y)+a_jg_j(x,y)$</li><li>两个性质<strong>加性和同质性</strong>，但我没有搜到相关信息，我觉得应该是可加性和齐次性</li></ul></li><li>非线性操作：不满足可加性和齐次性的。比如$max$操作</li></ul><h1 id="算数操作"><a href="#算数操作" class="headerlink" title="算数操作"></a>算数操作</h1><ul><li>相同size图片之间的加减乘除（<strong>注意都是对应元素之间的操作</strong>，就是Matlab里的点乘）</li><li>为了避免出现图像算术操作出现像素值$&lt;0$或者$&gt;255$的情况，对每幅图像进行如下操作<ul><li>$f_m = f-min(f)$</li><li>$f_s =  K[f_m/max(f_m+\delta)]$ 这样，像素值都在$[0,K]$之间，8bit图像就令K=255<ul><li>加$\delta$是为了防止出现除零的情况</li></ul></li><li>该方法可以用于 16bit或者更高比特的图像</li></ul></li></ul><h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><ul><li><p>和数学上的集合运算相同</p></li><li><p>集合里的元素是坐标$(x,y)$</p></li><li><p>默认集合里元素的灰度值是<strong>相同的</strong>（二值图像最适合）</p></li><li><p>灰度图像集合元素是三元的$(x,y,z)$，xy是坐标，z是灰度值</p><ul><li>集合$A = {(x,y,z)}$的补集$A^c = {(x,y,K-z)|(x,y,z)\in A}$<ul><li>$K = 2^k-1$，8bit的就是K = 255</li></ul></li><li>两个灰度集合的并集$$A\bigcup B = {max(a,b)|a\in A,b \in B}$$</li></ul></li><li><p>逻辑操作（适用于二值图像）</p><ul><li>和数学中逻辑操作相同</li><li>OR AND 也可以看作集合的操作</li></ul></li><li><p>模糊集合</p><ul><li>在第三章会讲</li></ul></li></ul><h1 id="空间操作"><a href="#空间操作" class="headerlink" title="空间操作"></a>空间操作</h1><p>分为以下几类</p><ol><li><p>单像素操作</p><ul><li>改变单个像素的灰度值</li></ul><p>$$s = T(z)$$</p><ul><li>z源像素灰度，s是变换之后像素灰度</li></ul></li><li><p>邻域操作</p><ul><li><p>令$S_{xy}$代表图像f中以任意一点$(x,y)$为中心的一个邻域的<strong>坐标集</strong></p></li><li><p>邻域处理再输出图像$g$中相同的坐标处生成一个相应的像素，生成值由输入坐标在$S_{xy}$内的像素经过操作决定（操作由你自己定义）</p></li><li><blockquote><p>比如取平均值操作$$g(x,y) = \frac{1}{mn}\sum_{(r,c)\in S_{xy}}f(r,c)$$</p></blockquote></li></ul></li><li><p>几何空间变换</p></li></ol><p>几何空间变换由两个基本操作组成 1）坐标的空间变换    2）灰度内插，即对空间变换后的像$素$赋灰度值</p><ul><li>坐标变换可由下式表示：$$(x,y) = T{(v,w)}$$<ul><li>$(v,w)$是原图像中的像素坐标，$(x,y)$是变换后图像中像素坐标、</li><li>比如$(x,y) = T{(v,w) = (v/2,w/2)}$表示在两个方向上把源图像缩小一半</li><li>最常用空间坐标变换：<strong>仿射变换</strong>；形式如下$$[x\space y\space 1] = [v\space w\space 1]\boldsymbol{A}=[x\space y\space 1]\begin{bmatrix}t_{11}&amp;t_{12}&amp;0 \\t_{21}&amp;t_{22}&amp;0\\t_{31}&amp;t_{32}&amp;1 \end{bmatrix}$$</li><li>上边的式子是<strong>前向映射</strong>，容易出现多个像素映射到同一点的情况，可以用<strong>反向映射</strong>解决$$(v,w) = \boldsymbol{T^{-1}}(x,y)$$</li></ul></li><li>估计变换函数：选取一定量的校准点（比如我取四个点），有一个参考图像，在两幅图像的相同位置进行标记<ul><li>假设变换方程 $x = c_1v+c_2w+c_3vw+c_4$， $y = c_5v+c_6w+c_7vw+c_8 $</li><li>带入四个点的坐标求出系数</li><li>带入系数求其他的点</li></ul></li></ul><h1 id="向量与矩阵的操作"><a href="#向量与矩阵的操作" class="headerlink" title="向量与矩阵的操作"></a>向量与矩阵的操作</h1><ul><li>对于RGB图像，可以把图像这样表示$$\boldsymbol z = \begin{bmatrix} z_1\\z_2\\z_3\end{bmatrix}$$</li><li>$z_1\space z_2 \space z_3$分别代表RGB层</li><li>可以用向量和矩阵的操作方法操作图片<ul><li>线性变换$w = A(z-a)$，A是m*n的矩阵，z和a是n*1的列向量</li><li>线性处理：$g = Hf+n$，f是输入图像，H是操作，n是噪声</li></ul></li></ul><h1 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h1><p>主要就是空间域和变换域的问题，<a href="https://blog.csdn.net/ice__snow/article/details/78633143" target="_blank" rel="noopener">这个博客讲的不错</a></p><h1 id="概率方法"><a href="#概率方法" class="headerlink" title="概率方法"></a>概率方法</h1><ul><li>统计某一灰度级出现的概率可估计为$p(z_k) = \frac{n_k}{MN}$<ul><li>$\sum^{L-1}_{k=0}p(z_k)=1$</li><li>方差$\sigma^2 = \sum^{L-1}_{k=0}(z_k-m)^2p(z_k)$</li><li>n阶矩$\mu_n(z) = \sum^{L-1}_{k=0}(z_k-m)^np(z_k)$</li></ul></li><li>均值和方差与图片的视觉特性有明显的直接关系，高阶矩更敏感<ul><li>比如三阶矩&gt;0表示灰度倾向于比均值高&lt;0说明灰度倾向于比均值低，0说明灰度近似相等的分布在均值附近</li></ul></li><li>概率方法在后面的图像处理中很有用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（四）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-si/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-si/</url>
      
        <content type="html"><![CDATA[<h1 id="计算器2-0"><a href="#计算器2-0" class="headerlink" title="计算器2.0"></a>计算器2.0</h1><p>上一篇所讲的计算器使用起来非常的麻烦，每次都要修改printf函数里的内容并且重新编译程序。</p><p>现在，让我们开始一步一步做出一个这样的计算器：</p><p><img src="https://img-blog.csdnimg.cn/20200213235721969.png" alt="有点意思"></p><h2 id="从窗口输入"><a href="#从窗口输入" class="headerlink" title="从窗口输入"></a>从窗口输入</h2><p>我们如何才能让程序读取到我们的输入呢？</p><p>这时候我们就需要用到另一个实用的函数：<strong>scanf()</strong></p><p>但是！还有一个问题我们需要解决： <strong>我们读取进来的数字放在哪?</strong></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>C语言中有个叫变量的东西可以存储我们的数据，它的定义方式很简单</p><p><code>数据类型 变量名</code>就可以定义一个变量，比如这就是一个名为 Trump的int型变量</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> Trump<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就是一个名为Donald的float类型变量</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> Donald<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="怎么使用变量呢？"><a href="#怎么使用变量呢？" class="headerlink" title="怎么使用变量呢？"></a>怎么使用变量呢？</h3><ul><li>首先，你可以在程序中为变量指定一个值，比如这样</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> Trump <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> Donald<span class="token punctuation">;</span>Donald <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>其次，我们可以利用scanf函数从控制台读取一个数字</li></ul><p><code>未完待续 2020年2月14日 22点49分</code></p><p>如果您有建议或者意见，欢迎在评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（三）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-san/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-san/</url>
      
        <content type="html"><![CDATA[<p>上一篇，我们讲了printf的基本用法，并写了一个简单的计算器。</p><p>还记得上一篇最后的<strong>任务</strong>吗？</p><blockquote><p>计算 3/2 的得数</p></blockquote><p>如果你的代码是这样的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那我们的程序会输出一个很奇怪的结果：<strong><em>1</em></strong></p><h1 id="为什么3-2会等于1？"><a href="#为什么3-2会等于1？" class="headerlink" title="为什么3/2会等于1？"></a>为什么3/2会等于1？</h1><p>要说明这个问题我们有必要先了解C语言是怎样存储和表示数字和字符的</p><h2 id="C语言基本数据类型"><a href="#C语言基本数据类型" class="headerlink" title="C语言基本数据类型"></a>C语言基本数据类型</h2><p>C语言有六种基本数据类型，他们分别是 short、long、int、float、double、char</p><p>在内存中，不同的类型占用不同的空间，short占2byte，int占4byte，long占4byte，float占2byte，double占8byte，char占1byte</p><blockquote><p>​    注：这个不绝对，可能会有所出入，应视具体情况而定</p></blockquote><h3 id="为什么引入数据类型"><a href="#为什么引入数据类型" class="headerlink" title="为什么引入数据类型"></a>为什么引入数据类型</h3><blockquote><p>如果你实在想知道，那我推荐这篇博文 <a href="https://www.2cto.com/kf/201707/654323.html" target="_blank" rel="noopener">数据类型的本质</a></p><blockquote><p>不懂什么是变量？不要着急，本篇后面会说明清楚</p></blockquote><p>不知道为什么并不影响你学习C语言</p></blockquote><h3 id="数据类型相互转化"><a href="#数据类型相互转化" class="headerlink" title="数据类型相互转化"></a>数据类型相互转化</h3><p>C语言是允许不同类型的数据相互转化的，但因为C语言内部存储机制的问题，有些时候这种转化会导致你丢失一些东西</p><p>比如，int类型表示的是整数，如果你把一个小数转换成整数，我们只能得到这个小数的整数部分，它小数点后面的部分都被丢弃了</p><blockquote><p>在程序中使用 类型名称(数据) ，可以强制转换类型</p><p>例如 int(1.5)可以把1.5这个小数转为int类型（但是只能得到1，小数部分被自动丢掉了）</p></blockquote><h3 id="为什么我们的程序输出了整数？"><a href="#为什么我们的程序输出了整数？" class="headerlink" title="为什么我们的程序输出了整数？"></a>为什么我们的程序输出了整数？</h3><p>理论上来讲3/2应该得到 1.5，根据分类，这应该是一个float或者double类型的小数，但是我们的程序却输出了 1 这个int类型的整数</p><p>这是因为有些时候C语言会自动帮你完成类型转换这一过程</p><p>还记得我们的程序吗</p><p>因为$3/2$所使用的<strong>两个数都是int类型</strong>，C语言会自动把他们的计算结果转换成整数，导致我们小数点后面数据的丢失</p><h3 id="如果修正？"><a href="#如果修正？" class="headerlink" title="如果修正？"></a>如果修正？</h3><p>这里有两个方法修正我们的程序</p><ol><li>根据<a href="https://www.cnblogs.com/weiyouqing/p/9090542.html" target="_blank" rel="noopener">C语言中不同类型的数据转换规则</a> （可点击进入查看转换规则），我们可以把表达式改为$3.0/2$（或者$3/2.0$、$3.0/2.0$）这样C语言会把表达式的结果记float类型</li><li>通过强制类型转换，我们可以强制把3变为浮点数<code>float(3)</code>或者把2变为浮点数<code>float(2)</code>，得到<code>float(3)/2</code>【或者<code>3/float(2)</code>、<code>float(3)/float(2)</code>】来达到我们的目的</li></ol><blockquote><p>注意：<code>float(3/2)</code>是不可以的，因为计算机在算$3/2$的时候就已经进行了丢弃数据（小数点后面内容）的操作，被丢掉的内容是无法还原的</p></blockquote><p>也许你已经改完了程序，它现在看起来是这样的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如果这时候运行程序，我们还是无法得到正确的答案"><a href="#如果这时候运行程序，我们还是无法得到正确的答案" class="headerlink" title="如果这时候运行程序，我们还是无法得到正确的答案"></a>如果这时候运行程序，我们还是无法得到正确的答案</h4><p>还记得之前所讲的<strong>占位符</strong>吗，对于int类型的数据，我们可以通过在文字里加上%d给整数占个位子。但现在时代变了，要想为$1.5$这个浮点数占个位子我们需要用<code>%f​</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3/2 = %f"</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行一下</p><p><img src="https://img-blog.csdnimg.cn/20200212235021995.png" alt="还不错"></p><p>没有问题，我们程序输出了正确的结果</p><p>但你可能会有一点完美主义情结——<strong>能不能不要让这破程序输出这么多零？</strong></p><p>对于这一点其实printf()也给我们提供了设置输出格式的方法，具体可以看<a href="https://blog.csdn.net/qq_29874741/article/details/94626531" target="_blank" rel="noopener">C语言printf()输出格式大全</a>，<strong>自己动手尝试</strong>不同的输出方式才能更快的学会。</p><p>如果您有更好的意见或者建议，请在评论区留言，感谢！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MiniZinc学习笔记</title>
      <link href="/2020/02/minizinc-xue-xi-bi-ji/"/>
      <url>/2020/02/minizinc-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>最近在Coursera上学了 <a href="https://www.coursera.org/learn/lisan-youhua-jianmo-jichupian" target="_blank" rel="noopener">离散优化建模</a>，里面介绍了MiniZinc这个建模语言，个人觉得比较新奇</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul><li><p>MiniZinc 语句顺序不重要</p><ul><li>你可以先定义变量再写表达式，这不是一个需要编译或者逐句解释得语言</li><li>写的程序主要是为了给后端得求解器描述问题</li></ul><ul><li>关于变量<ul><li>MiniZinc变量类型主要分为两大类<ul><li>参数</li><li>决策变量</li></ul></li></ul></li></ul></li></ul><p>其中<strong>参数</strong>类似于其他语言中的<strong>常量</strong>，<strong>只能在程序开始的时候被赋值</strong>而且<strong>只能被赋值一次</strong></p><p><strong>决策变量</strong>相当于其他语言中普通的可变变量（类似于方程中的未知数）</p><p><img src="https://img-blog.csdnimg.cn/20200210125011804.png" alt="变量声明"></p><p>可以看到，MiniZinc对于变量声明方式也是比较特殊的，形式为<code>变量类型描述:变量名称</code></p><p>当然，这两个分类只是从<strong>变量是不是常量</strong>的角度划分的</p><p>MiniZinc像其他语言一样，支持整数、浮点，数组、字符串、枚举、集合等类型</p><p>比如生成一个大小为10的int类型数组</p><ul><li>1..10代表从1到10的一个<strong>整数序列</strong></li><li>数组统一用array[]表示，方括号里边写数组包含的下标，图里的数组可以访问的下标范围是1~10</li><li>数组的下标可以是任意的类型（文字什么的也都可以，类似于字典，不过只能一对一）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200210125104691.png" alt="声明一个下标为1~10的int类型数组"></p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>MiniZinc是建模语言，它的主要作用是求解数学模型，我们光定义变量是不够的，一个模型除了$x,y,z$这样的变量还有会有很多的<strong>约束</strong>，比如$x = y+1$、$x\ge5$、$z\in R$ 等等，那么这些约束要怎样表达出来呢？</p><p>以一个简单的约束问题来看</p><p>$$x\in[-1,10],x\in Z,y=-(x-1)^2$$</p><p>求$max(y)$</p><p>很明显，这个问题的意思就是，x可以取从-1到10的整数（也就是x可以等于-1,0,1,2,3,4,5,6,7,8,9,10）$y=-(x-1)^2$ ，求一下 $y$ 的最大值</p><p>这个问题很简单，但足够用来说明MiniZinc的语法</p><p>首先我们定义变量x和y</p><pre><code>var int: x; %定义整数变量xvar int: y; %定义整数变量y</code></pre><p>接着，我们给x限定取值范围，并输入表达式 $y=-(x-1)^2$ ，这时候就需要用到我们的<strong>约束关键字</strong>了</p><pre><code>var int: x; %定义整数变量xvar int: y; %定义整数变量yconstraint x&gt;=-1;constraint x&lt;=10;constraint y = -((x-1)^2) %必须要加上括号，不然会出问题</code></pre><p>这里面，<strong>constraint</strong> 之后放上就是我们模型的约束</p><p>最后，我们要求最大值，使用 <strong>solve</strong> 语句</p><pre><code>var int: x; %定义整数变量xvar int: y; %定义整数变量yconstraint x&gt;=-1;constraint x&lt;=10;constraint y = -((x-1)^2) %必须要加上括号，不然会出问题solve maximize y;</code></pre><p><strong>solve</strong> 后面紧跟着我们想要的目标，maximize是MiniZinc内置的关键字，表示求最大值（最小值是minimize），后面接上y，表示求y这个变量的最大值</p><p>运行这个脚本，我们可以得到</p><blockquote><p>x=1;</p><p>y=0;</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对于这个脚本，我们可以进行一些优化，让脚本行数更少一些</p><blockquote><p>注意：一般来讲，模型的描述越紧凑，MiniZinc求解的速度越快，尤其是聚类等问题，越少使用constraint，求解速度越快</p></blockquote><p>首先，我们可以在变量定义的时候就限制x的取值范围</p><pre><code>var -1..10: x; %x可以是从-1到10的任意整数</code></pre><p>其次，我们可以在变量定义的时候就给y赋值</p><pre class="line-numbers language-\"><code class="language-\">var int: y = -((x-1)^2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们的脚本就优化成了这样</p><pre><code>var -1..10: x; var int: y=-((x-1)^2);solve maximize y;</code></pre><p>理论上，这样的模型具有更快的求解速度（不绝对，视求解器而定）</p><h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>我们发现，这个脚本运行以后只输出x的值，不输出y了</p><p>对此，我们需要指定脚本的输出格式。</p><p>语法如下</p><pre><code>output &lt;字符串列表&gt;;</code></pre><p>与C语言类似，字符串写在<kbd>"</kbd> <kbd>"</kbd>里面，也支持\t \n等转义符</p><p>对于如果要输出变量可以采用<strong>(变量名)</strong>的方式或者 <strong>“字符串”++show(变量名)</strong>的方式</p><blockquote><p>注意：MIniZinc里两个字符串之间用两个加号连接</p></blockquote><p>一般来讲，我们这样书写输出语句</p><pre><code>output [&quot;1+1 = &quot; ++ show(1+1)]; %写在方括号里，show函数把变量或者其他类型转为字符串类型</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MiniZinc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（二）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-er/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-er/</url>
      
        <content type="html"><![CDATA[<h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h1><blockquote><p>回顾：<br>在上一篇的教程中，我们了解了printf的功能和它的由来</p></blockquote><p>还记得我们上一篇的代码吗？</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，把<code>printf(&quot;Hello World&quot;);</code>改成<code>printf(&quot;1+1 = %d&quot;,1+1);</code><br>我们得到以下代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1+1 = %d"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，运行一下，来看看结果如何</p><p><img src="https://img-blog.csdnimg.cn/20200209215420217.png" alt="真理"><br>果然，如你料想的一样，这个程序输出了<strong>1+1 = 2</strong>这个真理</p><p>那么，让我们端详一下<strong>printf()括号里面</strong>的变化：</p><ul><li>等号后面有奇怪的 <strong>%d</strong></li><li>双引号外面多了个逗号，后面又有一个1+1</li></ul><p><code>如图所示</code><br><img src="https://img-blog.csdnimg.cn/20200209221042996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="代码的变化"><br>双引号里面的 <strong>%d</strong> 叫做<strong>占位符</strong>，顾名思义，<strong>%d</strong>只是替一个整数值占了个位置，在程序运行时后面<strong>1+1</strong>这个式子的结果会替换掉 <strong>%d</strong><br><img src="https://img-blog.csdnimg.cn/20200209221506654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="替换方式"></p><blockquote><p>注意：printf的使用要遵照这样的格式：<strong>printf(“格式化字符串”, 参数1, 参数2, … ,参数n)；</strong><br>其中<strong>格式化字符串</strong>是你想要输出的主要内容，参数1..n为放在文中占位符的东西，参数之间用<strong>英文逗号</strong>隔开</p></blockquote><p>C语言还支持很多其他的占位符，如表所示，在之后的章节中，我们随用随说</p><table><thead><tr><th>占位符</th><th>占的位置代表类型</th></tr></thead><tbody><tr><td>%c</td><td>一个字符</td></tr><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%i</td><td>十进制、八进制、十六进制整数</td></tr><tr><td>%o</td><td>八进制整数</td></tr><tr><td>%x</td><td>十六进制整数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%f,%F,%e,%E,%g,%G</td><td>实数，可以是小数或者指数形式</td></tr><tr><td>%u</td><td>无符号十进制整数</td></tr><tr><td>%%</td><td>百分号</td></tr></tbody></table><p>在上面简单计算器的基础上，我们可以做一些小的扩展，比如，我希望计算下面算式的结果</p><table><thead><tr><th>2+2</th><th>2*3</th><th>4➗2</th></tr></thead></table><p>根据我们上面所讲，我们可以可以尝试拼凑出下面的一行代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2+2 = %d, 2*3 = %d, 3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：C语言的除号是<kbd>/</kbd>，而不是➗</p></blockquote><p>把它替换掉原来的printf我们得到以下程序</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2+2 = %d, 2*3 = %d, 3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来运行一下这个程序，看一看结果<br><img src="https://img-blog.csdnimg.cn/20200209223323912.png" alt="倒是没算错"><br>当然，其实我们更希望程序能像下面这样分行输出</p><blockquote><p>2+2 = 4,<br>2*3 = 6,<br>4/2 = 2</p></blockquote><p>但经过之前的实践，我们知道不论是用多个printf还是加上回车我们都无法成功换行。</p><h1 id="如何换行？"><a href="#如何换行？" class="headerlink" title="如何换行？"></a>如何换行？</h1><p>这时候，就需要用到一个叫做转义符的东西 <strong>“\n”</strong>，我们把之前的代码改成这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2+2 = %d,\n 2*3 = %d,\n 3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会有效果吗？运行一下再说</p><p><img src="https://img-blog.csdnimg.cn/20200209223958979.png" alt="商业级排版"></p><p><strong>完美！</strong> 我们成功实现了让文字换行输出</p><p>别着急，还有一个新的问题</p><h1 id="什么是转义符？"><a href="#什么是转义符？" class="headerlink" title="什么是转义符？"></a>什么是转义符？</h1><p>简单来说就是我们把键盘上一些特殊的功能键（回车、制表符、退格……）设置成了一些指令，具体来讲，C语言支持以下转义符</p><table><thead><tr><th align="center">转义字符</th><th align="left">意义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="left">响铃(BEL)</td></tr><tr><td align="center">\b</td><td align="left">退格(BS) ，将当前位置移到前一列</td></tr><tr><td align="center">\f</td><td align="left">换页(FF)，将当前位置移到下页开头</td></tr><tr><td align="center">\n</td><td align="left">换行(LF) ，将当前位置移到下一行开头</td></tr><tr><td align="center">\r</td><td align="left">回车(CR) ，将当前位置移到本行开头</td></tr><tr><td align="center">\t</td><td align="left">水平制表(HT)</td></tr><tr><td align="center">\v</td><td align="left">垂直制表(VT)</td></tr><tr><td align="center">\\’</td><td align="left">单引号</td></tr><tr><td align="center">\\”</td><td align="left">双引号</td></tr><tr><td align="center">\\\</td><td align="left">反斜杠</td></tr></tbody></table><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>请尝试用本章所讲计算 3/2 的结果</p><p>如果您有建议或者意见，欢迎在评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（一）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-yi/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="关于编程环境"><a href="#关于编程环境" class="headerlink" title="关于编程环境"></a>关于编程环境</h1><p>网络上有很多C语言编程环境的配置教程，也有很多开箱即用的安装包，请大家自行摸索，对于学习来讲，微软的Visual Studio足以满足我们的需求。</p><p><code>注意：由于编译器不同，Visual Studio并不完全适合C语言开发，如果您的学校有具体的环境要求，还请遵照学校要求</code></p><blockquote><p>对于刚刚接触编程的新手，我本人<strong>不提倡</strong>直接在Linux环境编程（即使这样很装逼），也<strong>不提倡</strong>使用文本编辑器结合控制台指令编译的方式进行学习！</p></blockquote><h1 id="开篇：Hello-World"><a href="#开篇：Hello-World" class="headerlink" title="开篇：Hello World"></a>开篇：Hello World</h1><p>首先，请新建一个空白的文件，重命名为 Hello World.c<br>把下面的东西复制粘贴到你新建的文件里面</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用您ide的编译运行功能（一般快捷键为<kbd>F5</kbd>)，您应当能看到一个黑色窗口弹出，并显示如下文字<br><img src="https://img-blog.csdnimg.cn/2020020722072394.png" alt="你好，世界！"></p><p><code>没有显示，或者黑窗一闪而过？，请尝试以下代码！</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>我想现在你一定有很多的疑问，但请不要着急，接下来我会进行说明。</code></p><h2 id="关于printf-“Hello-World”"><a href="#关于printf-“Hello-World”" class="headerlink" title="关于printf(“Hello World”)"></a>关于printf(“Hello World”)</h2><p><strong>究竟是什么东西让我的屏幕上显示出了 Hello World ?</strong></p><p>如果你把程序进行修改，比如把双引号里面的 <em>Hello World</em> 换成 <em>您吃了吗？</em> ，你会发现程序的运行结果也随之改变。<br><strong>e.g.</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>换为</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更进一步，如果你把 <strong>printf(“您吃了吗？”);</strong> 多复制几次，比如这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，请保持您新输入的东西在 <strong>int main(){ </strong> 和 <strong>return 0</strong>之间，稍后我会说明原因</p></blockquote><p>再次运行程序，你会发现你的屏幕上出现了一连串来自电脑的亲切的问候.<br><img src="https://img-blog.csdnimg.cn/20200207223123544.png" alt="冬日里温暖的问候"></p><blockquote><p>当然，作为完美主义者，您可能并 <strong>不喜欢这些话挤在一行</strong> ，可如果你尝试在句子里添加回车，你会发现加再多的回车也<strong>没有效果</strong>，甚至会导致程序无法运行，请不要着急，稍后我会说明原因</p></blockquote><p>这时候，相信您已经猜到了，就是这个看起来很奇怪的 <strong>printf(“ “);</strong> 把我们投喂给它的东西放到了屏幕上</p><h3 id="printf-是什么，它是从哪来的？"><a href="#printf-是什么，它是从哪来的？" class="headerlink" title="printf()是什么，它是从哪来的？"></a>printf()是什么，它是从哪来的？</h3><p>还记得我们最开始的程序吗</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意看这一句</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>#include</strong>是什么？<br>如果我们说的专业一点就是</p><blockquote><p>#include 是C/C++中包含头文件命令，用于将指定头文件嵌入源文件中。<br>……来自百度百科</p></blockquote><p>当然，这样的解释对于新手来讲未免看的有些云里雾里。<br>为了深刻理解，我们不妨<strong>先删掉</strong>代码中的<code>#include &lt;stdio.h&gt;</code></p><p>我们的程序就变成了这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，如果我们重新编译运行程序，我们只会得到一条错误信息：<code>“printf”: 找不到标识符</code></p><p><code>注意：不同的ide对于错误提示可能有所不同</code></p><p>发生了什么？我们的编译器找不到<strong>printf</strong>了</p><p>那么是不是C语言本身并不包含<strong>printf</strong>这个东西，<strong>它其实是存在于其他人写好的文件当中</strong>呢?</p><p>确实是这样，C语言本身不能直接在屏幕上显示文字，<strong>前辈们</strong>为了方便后人编写程序，已经把输出文字的功能写好，并装在了<strong>stdio.h</strong>文件里头</p><p>而 <code>#include&lt;stdio.h&gt;</code> 就是告诉你的编译器把<code>stdio.h</code>这个文件的内容加载到你的程序里面，让你能直接使用前辈的智慧结晶</p><p><code>注意：stdio.h 里并不包含printf的完整实现，之后我会说明清楚</code></p><p>这里面，<strong>前辈写的程序</strong>被<strong>包装</strong>成了<strong>函数</strong>，<strong>函数</strong>有个<strong>名字</strong>叫做<strong>printf</strong></p><p><strong>什么是函数？</strong>，这里我不做过多解释，你完全可以认为<strong>函数就是</strong>一个黑盒子、一个<strong>自动炒菜锅</strong>，你把<strong>菜</strong>放<strong>进括号</strong>，<strong>他给你炒出你要的菜</strong></p><blockquote><p>不懂什么是 <strong>函数</strong> ？ 不要着急，之后我会花一章来慢慢说明</p></blockquote><p>现在，我们知道，<strong>printf</strong>来自<strong>stdio.h</strong>（全称 standard input &amp; output 即标准输入输出）这个文件，它由前辈们编写，为了方便我们编写其他的C程序。</p><p>如果您有建议或者意见，欢迎在评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
