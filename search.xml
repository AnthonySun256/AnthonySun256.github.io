<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用simulink产生三角脉冲的正确方法</title>
      <link href="/2020/05/yong-simulink-chan-sheng-san-jiao-mai-chong-de-zheng-que-fang-fa/"/>
      <url>/2020/05/yong-simulink-chan-sheng-san-jiao-mai-chong-de-zheng-que-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="产生三角波（脉冲）"><a href="#产生三角波（脉冲）" class="headerlink" title="产生三角波（脉冲）"></a>产生三角波（脉冲）</h1><p>有两种方法，一个是使用simulink自带的Repeating sequence模块，可以在模块设置界面设置脉冲的形状和周期，方法比较简单。</p><p>第二种是使用Matlab Function模块，如图所示<br><img src="https://img-blog.csdnimg.cn/20200527135220246.jpg#pic_center" alt="Matlab Function模块"><br>双击该模块出现脚本编辑界面，这里我使用以下代码。(代码高亮好像不支持matlab。。。)</p><pre class="line-numbers language-Matlab"><code class="language-Matlab">function y = fcn(time,delta)if time <=delta    y = time/delta^2;elseif time< delta*2    y = 1/delta-(time-delta)/delta^2;else    y = 0;endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它接收一个时钟信号<code>time</code>和$\delta$产生一个宽度为 $2\delta$ 峰值为$\frac{1}{\delta}$ ，面积为<code>1</code>的三角脉冲，其$\delta = 0.25$时的图像如图所示<br><img src="https://img-blog.csdnimg.cn/20200527135556121.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70#pic_center" alt="delta = 0.25时的波形"></p><h1 id="三角波失真"><a href="#三角波失真" class="headerlink" title="三角波失真"></a>三角波失真</h1><h2 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h2><p><strong>仿真时间为2s时</strong></p><p>上一节介绍了两种产生三角波的方法在使用过程中，如果$\delta$ 过小，比如<code>0.1</code> 和<code>0.0025</code>其理想中的图形应该时这样的</p><p><img src="https://img-blog.csdnimg.cn/20200527142025173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="delta =0.0025"><br><img src="https://img-blog.csdnimg.cn/20200527142054172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="delta = 0.1"></p><p><strong>但是在默认情况下simulink输出的波形却是这样的</strong>，可以发现$\delta = 0.1$的三角形尖的部分被削去了，$\delta = 0.0025$干脆啥都没有了</p><p><img src="https://img-blog.csdnimg.cn/20200527135925555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="失真的delta = 0.1"><br><img src="https://img-blog.csdnimg.cn/2020052714040582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="消失的delta = 0.0025"><br>如果把这两个波形($\delta = 0.0025$和$\delta =0.1$)分别输入如图所示的一阶系统($\frac{dy(t)}{dt(t)}+2y(t) =x(t)$)中，则会产生如图的冲激响应<br><img src="https://img-blog.csdnimg.cn/20200527141304233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="一阶系统"><br><img src="https://img-blog.csdnimg.cn/20200527141145143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="delta = 0.0025时的响应"><br><img src="https://img-blog.csdnimg.cn/20200527141212355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="delta = 0.1时的响应"></p><p>可以看到，simulink没有正确计算$\delta = 0.0025$（啥都没有），$\delta = 0.1$也出现了明显的失真</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>经过分析，其原因在于simulink在仿真时，仿真时间步长相对固定（具体根据使用到的元件自动确定，但一般不会太高），如果脉冲持续时间过短则会导致仿真过程中跳过一些时间点。</p><p>例如在$\delta = 0.0025$时波形出现失真就是因为在$time = 0.0025$处在两个时间节点之间</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>调整sikmulink的仿真时间步长可以解决这个问题，具体设置方法如图所示</p><ol><li>按下ctrl+e快捷键打开Model settings</li><li>修改方框圈起来的参数（根据实际需要修改最大和最小时间步长，这里$\delta$最小为<code>0.0025</code>所以我就设置最大时间步长为<code>0.0001</code>，最小时间步长为<code>0.00001</code>，以尽可能平滑）</li></ol><p><img src="https://img-blog.csdnimg.cn/20200527141725592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="Model steeings设置"></p><p>之后再次运行仿真，我们可以看到simulink产生了很好的三角脉冲<br><img src="https://img-blog.csdnimg.cn/20200527142025173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="delta =0.0025"><br><img src="https://img-blog.csdnimg.cn/20200527142054172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="delta = 0.1"></p><h1 id="一阶系统对不同-delta-的相应"><a href="#一阶系统对不同-delta-的相应" class="headerlink" title="一阶系统对不同$\delta$的相应"></a>一阶系统对不同$\delta$的相应</h1><p><strong>仿真时间为<code>2s</code></strong> ，把三角脉冲($\delta = 0.0025$)输入<strong>之前说的</strong>一阶系统，观察响应与理想的冲激响应做对比</p><p>三角脉冲响应<br><img src="https://img-blog.csdnimg.cn/20200527142346976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="delta = 0.0025时的响应"><br>理想冲击响应<br><img src="https://img-blog.csdnimg.cn/20200527142600561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="理想冲击响应"></p><p>系统对不同$\delta$取值的响应</p><p><img src="https://img-blog.csdnimg.cn/20200527142647748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="系统对不同宽度三角脉冲的响应"></p>]]></content>
      
      
      <categories>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三角脉冲  simulink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于getline等函数无法正确读入问题</title>
      <link href="/2020/05/guan-yu-shu-ru-liu-qing-kong-wen-ti/"/>
      <url>/2020/05/guan-yu-shu-ru-liu-qing-kong-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>之前在修改一个程序的时候遇到这样一个bug：</p><p>程序需要读入一整以换行符结尾的字符串，一开始使用了<code>cin.getline()</code>方法，但是在实际应用中程序未读入任何字符，其使用的方法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdarg></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//do somthing</span>    <span class="token keyword">char</span> a_long_string_include_blank_char<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">getline</span><span class="token punctuation">(</span>a_long_string_include_blank_char<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但如果实际使用，则会发现当程序执行到第九行的时候并没有提示输入任何字符，<strong>a_long_string_include_blank_char</strong>中也未存储任何内容</p><h1 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h1><p>经查阅相关文档，发现问题原因如下：</p><p>使用 <code>::std::cin &gt;&gt; xxx</code>时，其结尾存在的<strong>空白字符</strong>并不会被抛弃，而是<strong>保留在了输入流中</strong>。</p><p>这一点使用以下程序可以进行确定</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdarg></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//do somthing</span>    <span class="token keyword">char</span> a_char<span class="token punctuation">;</span>    a_char <span class="token operator">=</span> <span class="token operator">::</span>std<span class="token operator">::</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面代码，并输入数字，回车。可以发现<strong>a_char</strong>中存储了换行符<strong>‘\n’</strong></p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>对于这个问题，搜索引擎所给出的答案并不能完全解决，或者说只能解决一部分问题。</p><p>经过尝试，以下两种方法可以解决几乎全部输入问题</p><ol><li><p>使用<code>std::cin &gt;&gt; std::ws</code></p><p>对于<code>std::ws</code>，cppreference给出的解释如下：</p><blockquote><p>从输入流舍弃前导空白符。</p><p>表现为<a href="https://zh.cppreference.com/w/cpp/named_req/UnformattedInputFunction" target="_blank" rel="noopener"><em>无格式输入函数</em> <em>(UnformattedInputFunction)</em> </a>，除了不修改 is.gcount() 。在构造并检查 sentry 对象后，从流释出并舍弃字符，直至出现任何下列条件之一：</p><ul><li><p>输入序列中出现文件尾条件（该情况下函数调用 setstate(eofbit) 但不设置 <code>failbit</code> ；若调用 <code>ws</code> 前已在 <code>is</code> 上设置 <code>eofbit</code> ，则不适用这条，该情况下 sentry 对象的构造会设置 <code>failbit</code> ）。</p></li><li><p>输入序列中下个可用字符 <code>c</code> 不是以 std::isspace(c, is.getloc()) 确定的空白字符。不释出该非空白字符。</p></li></ul><p>这是仅为输入的 I/O 操纵符，可用如 in &gt;&gt; std::ws 的表达式对任何 <a href="https://zh.cppreference.com/w/cpp/io/basic_istream" target="_blank" rel="noopener">std::basic_istream</a> 类型的 <code>in</code> 调用。</p></blockquote></li></ol><p>使用<code>std::ws</code> 解决问题代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdarg></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//do somthing</span>    <span class="token keyword">char</span> a_long_string_include_blank_char<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> <span class="token operator">::</span>std<span class="token operator">::</span>ws<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//去除输入流中空白字符</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">getline</span><span class="token punctuation">(</span>a_long_string_include_blank_char<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>使用<code>cin.ignore</code> (存在问题)</p><p>这个方法是百度上解决相关问题提到最多的了，但是百度上得到的用法大多都<strong>不正确！</strong></p><p>cppreference给出关于ignore解释如下</p><blockquote><p>从输入流释出并舍弃字符，直至并包含 <code>delim</code> 。</p><p><code>ignore</code> 表现为<a href="https://zh.cppreference.com/w/cpp/named_req/UnformattedInputFunction" target="_blank" rel="noopener"><em>无格式输入函数</em> <em>(UnformattedInputFunction)</em> </a>。构造并检查 sentry 对象后，它从流释出并舍弃字符，直至出现任一下列条件：</p><ul><li><p>已释出 <code>count</code> 个字符。在 <code>count</code> 等于 <a href="http://zh.cppreference.com/w/cpp/types/numeric_limits" target="_blank" rel="noopener">std::numeric_limits</a>&lt;<a href="http://zh.cppreference.com/w/cpp/io/streamsize" target="_blank" rel="noopener">std::streamsize</a>&gt;::max() 的特殊情况下禁用此测试。</p></li><li><p>输入序列中出现文件尾条件，该情况下函数调用 setstate(eofbit) 。</p></li><li><p>输入序列中下个可用字符 <code>c</code> 为 <code>delim</code> ，以 Traits::eq_int_type(Traits::to_int_type(c), delim) 确定。释出并舍弃分隔符。若 Traits::eof() 为则禁用此测试。</p></li></ul></blockquote><p>而一些人博客中所写的<code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max())</code>则会无限制的吞噬输入的字符</p><p>如果要修复<strong>输入流中存在换行符的问题</strong>，则应按照如下方法使用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdarg></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> operator_to_do_somthing<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//do somthing</span>    <span class="token keyword">char</span> a_long_string_include_blank_char<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span><span class="token operator">::</span>std<span class="token operator">::</span>numeric_limits<span class="token operator">&lt;</span>std<span class="token operator">::</span>streamsize<span class="token operator">></span><span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//去除输入流中'\n'之前所有字符(包括'\n')</span>    <span class="token operator">::</span>std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">getline</span><span class="token punctuation">(</span>a_long_string_include_blank_char<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这种方法会存在问题，按照程序中的例子来讲，如果输入的是”12 How are you?\n”</p><p>则之后的<code>cin.getline</code>并不能正确的获取到字符串”How are you?”</p><p>因为上面程序中ignor结尾条件是换行符<code>\n</code> 而不是空格，所以输入流中的” How are you?\n”都被抛弃了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>识别手写数字</title>
      <link href="/2020/03/shi-bie-shou-xie-shu-zi/"/>
      <url>/2020/03/shi-bie-shou-xie-shu-zi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> keras<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> mnist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>Using TensorFlow backend.</code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">(</span>train_images<span class="token punctuation">,</span> train_labels<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>test_images<span class="token punctuation">,</span>test_labels<span class="token punctuation">)</span> <span class="token operator">=</span> mnist<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> keras <span class="token keyword">import</span> models<span class="token keyword">from</span> keras <span class="token keyword">import</span> layers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#定义一个神经网络</span>network <span class="token operator">=</span> models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>network<span class="token punctuation">.</span>add<span class="token punctuation">(</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span>activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">,</span> input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输入大小为28*28的全连接网络，这里是给展开成一维的了，就像是吴恩达课程的手写识别一样，，把28*28的2D展开成了1维向量</span>network<span class="token punctuation">.</span>add<span class="token punctuation">(</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>activation<span class="token operator">=</span><span class="token string">'softmax'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#softamx，输出10个概率值（和为1），每个概率表示当前图像属于10个数字类别中摸一个的概率</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#编译神经网络</span><span class="token comment" spellcheck="true">#损失函数（ loss function）：网络如何衡量在训练数据上的性能，即网络如何朝着正确的方向前进。</span><span class="token comment" spellcheck="true">#优化器（ optimizer）：基于训练数据和损失函数来更新网络的机制。</span><span class="token comment" spellcheck="true">#在训练和测试过程中需要监控的指标（ metric）：本例只关心精度，即正确分类的图像所占的比例。</span>network<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>loss<span class="token operator">=</span><span class="token string">'categorical_crossentropy'</span><span class="token punctuation">,</span>                optimizer<span class="token operator">=</span><span class="token string">'rmsprop'</span><span class="token punctuation">,</span>                metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#处理训练数据，进行归一化处理、把图像从2维转为1维向量，并把格式从uint8转到float32</span><span class="token comment" spellcheck="true">#训练图像的1维展开和归一化</span>train_images <span class="token operator">=</span> train_images<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">60000</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>train_images <span class="token operator">=</span> train_images<span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">'float32'</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span class="token comment" spellcheck="true">#测试数据的一维展开和归一化</span>test_images <span class="token operator">=</span> test_images<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>test_images <span class="token operator">=</span> test_images<span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">'float32'</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#对标签进行分类编码</span><span class="token keyword">from</span> keras<span class="token punctuation">.</span>utils <span class="token keyword">import</span> to_categoricaltrain_labels <span class="token operator">=</span> to_categorical<span class="token punctuation">(</span>train_labels<span class="token punctuation">)</span>test_labels <span class="token operator">=</span> to_categorical<span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">test_labels<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>array([[0., 0., 0., ..., 1., 0., 0.],       [0., 0., 1., ..., 0., 0., 0.],       [0., 1., 0., ..., 0., 0., 0.],       ...,       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.]], dtype=float32)</code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#开始训练模型</span>network<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_images<span class="token punctuation">,</span> train_labels<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>Epoch 1/560000/60000 [==============================] - 2s 32us/step - loss: 0.2540 - accuracy: 0.9267Epoch 2/560000/60000 [==============================] - 1s 23us/step - loss: 0.1039 - accuracy: 0.9692Epoch 3/560000/60000 [==============================] - 1s 23us/step - loss: 0.0683 - accuracy: 0.9803Epoch 4/560000/60000 [==============================] - 1s 20us/step - loss: 0.0496 - accuracy: 0.9851Epoch 5/560000/60000 [==============================] - 1s 19us/step - loss: 0.0377 - accuracy: 0.9882&lt;keras.callbacks.callbacks.History at 0x21d28ac8d68&gt;</code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#评价模型</span>test_loss<span class="token punctuation">,</span> test_acc <span class="token operator">=</span> network<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span>test_images<span class="token punctuation">,</span>test_labels<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'test_acc:'</span><span class="token punctuation">,</span>test_acc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>10000/10000 [==============================] - 1s 77us/steptest_acc: 0.9814000129699707</code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#显示数字</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltdigit <span class="token operator">=</span> train_images<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>digit<span class="token punctuation">,</span> cmap <span class="token operator">=</span> plt<span class="token punctuation">.</span>cm<span class="token punctuation">.</span>binary<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电影评论分类（二分类问题）</title>
      <link href="/2020/03/dian-ying-ping-lun-fen-lei-er-fen-lei-wen-ti/"/>
      <url>/2020/03/dian-ying-ping-lun-fen-lei-er-fen-lei-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>本节使用 IMDB 数据集，它包含来自互联网电影数据库（ IMDB）的 50 000 条严重两极分<br>化的评论。数据集被分为用于训练的 25 000 条评论与用于测试的 25 000 条评论，训练集和测试<br>集都包含 50% 的正面评论和 50% 的负面评论。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> keras<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> imdb<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_labels<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> test_labels<span class="token punctuation">)</span> <span class="token operator">=</span> imdb<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span>num_words<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># num_words意思是仅保留训练数据中前10000个最常出现的单词，低频的词会被舍弃。这样得到的向量数据不会太大，便于处理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>Using TensorFlow backend.</p></blockquote><p>train_data 和 test_data 这两个变量都是评论组成的列表，每条评论又是单词索引组成<br>的列表（表示一系列单词）。 train_labels 和 test_labels 都是 0 和 1 组成的列表，其中 0<br>代表负面（ negative）， 1 代表正面（ positive）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#把评论解码为英文单词</span>word_index <span class="token operator">=</span> imdb<span class="token punctuation">.</span>get_word_index<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#得到 英文->数字的字典</span><span class="token comment" spellcheck="true">#得到 数字->英文的字典</span><span class="token comment" spellcheck="true">#以上的映射肯定是一对一的</span>reverse_word_index <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> word_index<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>decoded_review <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>reverse_word_index<span class="token punctuation">.</span>get<span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> train_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#索引减去了 3，因为 0、 1、 2是为“padding”（填充）、“start of sequence”（序列开始）、“unknown”（未知词）分别保留的索引</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train_data[0]:'</span><span class="token punctuation">,</span> decoded_review<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>train_data[0]: ? this film was just brilliant casting location scenery story direction everyone’s really suited the part they played and you could just imagine being there robert ? is an amazing actor and now the same being director ? father came from the same scottish island as myself so i loved the fact there was a real connection with this film the witty remarks throughout the film were great it was just brilliant so much that i bought the film as soon as it was released for ? and would recommend it to everyone to watch and the fly fishing was amazing really cried at the end it was so sad and you know what they say if you cry at a film it must have been good and this definitely was also ? to the two little boy’s that played the ? of norman and paul they were just brilliant children are often left out of the ? list i think because the stars that play them all grown up are such a big profile for the whole film but these children are amazing and should be praised for what they have done don’t you think the whole story was so lovely because it was true and was someone’s life after all that was shared with us all</p></blockquote><p>你不能将整数序列直接输入神经网络。你需要将列表转换为张量。转换方法有以下两种。</p><ul><li>填充列表，使其具有相同的长度，再将列表转换成形状为 (samples, word_indices)<br>的整数张量，然后网络第一层使用能处理这种整数张量的层（即 Embedding 层，本书<br>后面会详细介绍）。</li><li>对列表进行 one-hot 编码，将其转换为 0 和 1 组成的向量。举个例子，序列 [3, 5] 将会<br>被转换为 10 000 维向量，只有索引为 3 和 5 的元素是 1，其余元素都是 0。然后网络第<br>一层可以用 Dense 层，它能够处理浮点数向量数据。<br>下面我们采用后一种方法将数据向量化。为了加深理解，你可以手动实现这一方法，如下<br>所示。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#准备数据</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">vectorize_sequences</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> dimension<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    results <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>sequences<span class="token punctuation">)</span><span class="token punctuation">,</span> dimension<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> sequence <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>sequences<span class="token punctuation">)</span><span class="token punctuation">:</span>        results<span class="token punctuation">[</span>i<span class="token punctuation">,</span> sequence<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> resultsx_train <span class="token operator">=</span> vectorize_sequences<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>x_test <span class="token operator">=</span> vectorize_sequences<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#准备标签(本来就是0 1 的取值，直接变为浮点型的np数组就行)</span>y_train <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>train_labels<span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">'float32'</span><span class="token punctuation">)</span>y_test <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span><span class="token string">'float32'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#构建网络</span><span class="token keyword">from</span> keras <span class="token keyword">import</span> models<span class="token punctuation">,</span> layersnetwork <span class="token operator">=</span> models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>network<span class="token punctuation">.</span>add<span class="token punctuation">(</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>network<span class="token punctuation">.</span>add<span class="token punctuation">(</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span>activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>network<span class="token punctuation">.</span>add<span class="token punctuation">(</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>什么是激活函数？为什么要使用激活函数？<br>如果没有 relu 等激活函数（也叫非线性）， Dense 层将只包含两个线性运算——点积<br>和加法：<br>output = dot(W, input) + b<br>这样 Dense 层就只能学习输入数据的线性变换（仿射变换）：该层的假设空间是从输<br>入数据到 16 位空间所有可能的线性变换集合。这种假设空间非常有限，无法利用多个表示<br>层的优势，因为多个线性层堆叠实现的仍是线性运算，添加层数并不会扩展假设空间。<br>为了得到更丰富的假设空间，从而充分利用多层表示的优势，你需要添加非线性或激<br>活函数。 relu 是深度学习中最常用的激活函数，但还有许多其他函数可选，它们都有类似<br>的奇怪名称，比如 prelu、 elu 等。</p><p>最后，你需要选择损失函数和优化器。由于你面对的是一个二分类问题，网络输出是一<br>个概率值（网络最后一层使用 sigmoid 激活函数，仅包含一个单元），那么最好使用 binary_<br>crossentropy（二元交叉熵）损失。这并不是唯一可行的选择，比如你还可以使用 mean_<br>squared_error（均方误差）。但对于输出概率值的模型， 交叉熵（ crossentropy）往往是最好<br>的选择。交叉熵是来自于信息论领域的概念，用于衡量概率分布之间的距离，在这个例子中就<br>是真实分布与预测值之间的距离</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#编译网络</span><span class="token comment" spellcheck="true">#这里使用了默认的优化器、损失函数和度量方法</span>network<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>optimizer<span class="token operator">=</span><span class="token string">'rmsprop'</span><span class="token punctuation">,</span>                loss<span class="token operator">=</span><span class="token string">'binary_crossentropy'</span><span class="token punctuation">,</span>                metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#或者使用自定义的参数进行训练</span><span class="token keyword">from</span> keras <span class="token keyword">import</span> optimizers<span class="token keyword">from</span> keras <span class="token keyword">import</span> losses<span class="token keyword">from</span> keras <span class="token keyword">import</span> metrics<span class="token comment" spellcheck="true">#学习率设为0.01</span>model<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>optimizer<span class="token operator">=</span>optimizers<span class="token punctuation">.</span>RMSprop<span class="token punctuation">(</span>lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">,</span>loss<span class="token operator">=</span>losses<span class="token punctuation">.</span>binary_crossentropy<span class="token punctuation">,</span>metrics<span class="token operator">=</span><span class="token punctuation">[</span>metrics<span class="token punctuation">.</span>binary_accuracy<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#把前10000个样本作验证集</span>x_val <span class="token operator">=</span> x_train<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10000</span><span class="token punctuation">]</span>partial_x_train <span class="token operator">=</span> x_train<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">:</span><span class="token punctuation">]</span>y_val <span class="token operator">=</span> y_train<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10000</span><span class="token punctuation">]</span>partial_y_train <span class="token operator">=</span> y_train<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#使用交叉验证集，用来验证模型是否过拟合</span><span class="token comment" spellcheck="true">#！！！这里不应该用测试集代替验证集！！！！</span><span class="token comment" spellcheck="true">#测试集是用来测试模型的泛化能力的</span>history <span class="token operator">=</span> network<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>partial_x_train<span class="token punctuation">,</span>                      partial_y_train<span class="token punctuation">,</span>                      validation_data<span class="token operator">=</span><span class="token punctuation">(</span>x_val<span class="token punctuation">,</span>y_val<span class="token punctuation">)</span><span class="token punctuation">,</span>                      batch_size<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>                      epochs<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Train on 15000 samples, validate on 10000 samples<br>Epoch 1/20<br>15000/15000 [==============================] - 5s 311us/step - loss: 0.5258 - accuracy: 0.7988 - val_loss: 0.4014 - val_accuracy: 0.8655<br>Epoch 2/20<br>15000/15000 [==============================] - 2s 116us/step - loss: 0.3251 - accuracy: 0.8949 - val_loss: 0.3164 - val_accuracy: 0.8811<br>Epoch 3/20<br>15000/15000 [==============================] - 2s 116us/step - loss: 0.2349 - accuracy: 0.9259 - val_loss: 0.2903 - val_accuracy: 0.8843<br>Epoch 4/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.1874 - accuracy: 0.9377 - val_loss: 0.2722 - val_accuracy: 0.8906<br>Epoch 5/20<br>15000/15000 [==============================] - 2s 116us/step - loss: 0.1514 - accuracy: 0.9510 - val_loss: 0.2907 - val_accuracy: 0.8845<br>Epoch 6/20<br>15000/15000 [==============================] - 2s 116us/step - loss: 0.1261 - accuracy: 0.9599 - val_loss: 0.2893 - val_accuracy: 0.8865<br>Epoch 7/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.1059 - accuracy: 0.9663 - val_loss: 0.2994 - val_accuracy: 0.8837<br>Epoch 8/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.0871 - accuracy: 0.9759 - val_loss: 0.3576 - val_accuracy: 0.8719<br>Epoch 9/20<br>15000/15000 [==============================] - 2s 116us/step - loss: 0.0722 - accuracy: 0.9813 - val_loss: 0.3443 - val_accuracy: 0.8809<br>Epoch 10/20<br>15000/15000 [==============================] - 2s 116us/step - loss: 0.0604 - accuracy: 0.9837 - val_loss: 0.3737 - val_accuracy: 0.8785<br>Epoch 11/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.0487 - accuracy: 0.9880 - val_loss: 0.3988 - val_accuracy: 0.8740<br>Epoch 12/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.0414 - accuracy: 0.9895 - val_loss: 0.4196 - val_accuracy: 0.8766<br>Epoch 13/20<br>15000/15000 [==============================] - 2s 118us/step - loss: 0.0305 - accuracy: 0.9941 - val_loss: 0.4521 - val_accuracy: 0.8741<br>Epoch 14/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.0252 - accuracy: 0.9956 - val_loss: 0.5127 - val_accuracy: 0.8695<br>Epoch 15/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.0200 - accuracy: 0.9972 - val_loss: 0.5208 - val_accuracy: 0.8722<br>Epoch 16/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.0165 - accuracy: 0.9976 - val_loss: 0.5612 - val_accuracy: 0.8667<br>Epoch 17/20<br>15000/15000 [==============================] - 2s 117us/step - loss: 0.0114 - accuracy: 0.9989 - val_loss: 0.5856 - val_accuracy: 0.8688<br>Epoch 18/20<br>15000/15000 [==============================] - 2s 118us/step - loss: 0.0120 - accuracy: 0.9981 - val_loss: 0.6191 - val_accuracy: 0.8677<br>Epoch 19/20<br>15000/15000 [==============================] - 2s 124us/step - loss: 0.0060 - accuracy: 0.9998 - val_loss: 0.6925 - val_accuracy: 0.8622<br>Epoch 20/20<br>15000/15000 [==============================] - 2s 128us/step - loss: 0.0094 - accuracy: 0.9983 - val_loss: 0.6941 - val_accuracy: 0.8657</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#绘制损失函数曲线，评估模型</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plthistory_dict <span class="token operator">=</span> history<span class="token punctuation">.</span>historyloss_values <span class="token operator">=</span> history_dict<span class="token punctuation">[</span><span class="token string">'loss'</span><span class="token punctuation">]</span>val_loss_values <span class="token operator">=</span> history_dict<span class="token punctuation">[</span><span class="token string">'val_loss'</span><span class="token punctuation">]</span>epochs <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>loss_values<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>epochs<span class="token punctuation">,</span> loss_values<span class="token punctuation">,</span> <span class="token string">'bo'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Training loss'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>epochs<span class="token punctuation">,</span> val_loss_values<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Validation loss'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Training and validation loss'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Epochs'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Loss'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，模型明显过拟合了应该尝试减小迭代次数，但是这里只是学习，问题不大</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#绘制精度曲线</span>plt<span class="token punctuation">.</span>clf<span class="token punctuation">(</span><span class="token punctuation">)</span>acc <span class="token operator">=</span> history_dict<span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span>val_acc <span class="token operator">=</span> history_dict<span class="token punctuation">[</span><span class="token string">'val_accuracy'</span><span class="token punctuation">]</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>epochs<span class="token punctuation">,</span> acc<span class="token punctuation">,</span> <span class="token string">'bo'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Training acc'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>epochs<span class="token punctuation">,</span> val_acc<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Validation acc'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Training and validation accuracy'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Epochs'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Accuracy'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#预测一个样本为好评的可能</span>network<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>x_test<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>array([[8.421981e-05]], dtype=float32)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数字图像处理》第三章笔记</title>
      <link href="/2020/02/shu-zi-tu-xiang-chu-li-di-san-zhang-bi-ji/"/>
      <url>/2020/02/shu-zi-tu-xiang-chu-li-di-san-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章主要讲的是<strong>空间域</strong>的操作（即图像本身）</p></blockquote><p>本章主要讨论形如$g(x,y) = T[f(x,y)]$的灰度变换和空间滤波</p><p>上面的公式也可以写成更一般的形式$$s = T(r)$$</p><ul><li><p>$s、r$分别表示输出图像和源图像</p></li><li><p>操作$T$可以是对邻域的操作（比如对图像进行模糊操作）</p></li></ul><p>灰度变换和空间滤波可用于<strong>图像增强</strong></p><p>灰度变换可以是一个简单的映射（比如$T$代表查表操作，源图像每一个灰度值在表里头都有一个对应的灰度值作为输出）</p><h1 id="基本灰度变换函数"><a href="#基本灰度变换函数" class="headerlink" title="基本灰度变换函数"></a>基本灰度变换函数</h1><h2 id="图像反转"><a href="#图像反转" class="headerlink" title="图像反转"></a>图像反转</h2><p>$s = 255 - r$，就是一个8bit灰度图像的反转方法，可以做出来底片的效果</p><h2 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h2><p>$$s = c\log{(1+r)}, r\ge0,c=const$$</p><p>可以把灰度值中范围较窄<strong>低灰度值</strong>范围映射到一个范围较宽的灰度值范围，或者把范围较宽的<strong>高灰度值</strong>范围压缩为范围较窄的灰度值范围</p><ul><li>用来拓展图片中<strong>暗的像素</strong>（让本来暗的地方亮一些），同时压缩高灰度</li><li><strong>反对数函数</strong>作用效果正好相反</li><li>以上结论可以看对数函数图像得知</li><li>对数变换可用于傅里叶频谱的校正（傅里叶频谱输出值很大($10^6$级别)会丢失灰度值小的像素信息（因为只用8bit存储），但取对数后可以压缩为个位数防止信息丢失过多）</li></ul><h2 id="幂律（伽马）变换"><a href="#幂律（伽马）变换" class="headerlink" title="幂律（伽马）变换"></a>幂律（伽马）变换</h2><p>$$s = cr^\gamma$$</p><ul><li>$\gamma &gt;1$和$\gamma &lt;1$时的效果<strong>完全相反</strong></li><li>用于伽马矫正，压缩一些灰度范围，扩展一些灰度范围</li><li>可以增强对比度</li><li>增强暗部，或者减少亮部</li></ul><h2 id="分段线性变换函数"><a href="#分段线性变换函数" class="headerlink" title="分段线性变换函数"></a>分段线性变换函数</h2><p>优点是可以任意复杂，缺点是需要用户手动输入</p><ul><li>同样可以应用于对比度拉伸的操作</li><li>可以用于<strong>灰度级分层</strong></li><li>用于<strong>比特平面分层</strong>，<a href="https://blog.csdn.net/qq_19332527/article/details/78331240" target="_blank" rel="noopener">这篇博客的代码有助于理解</a></li></ul><h2 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h2><p>一般采用统计每个灰度值的像素个数，除以总像素个数，得到一个频率。</p><p>根据这个频率做出直方图</p><h3 id="直方图均衡"><a href="#直方图均衡" class="headerlink" title="直方图均衡"></a>直方图均衡</h3><p>$$s=T(r)$$</p><p>这个博客讲的挺好：<a href="https://blog.csdn.net/qq_15971883/article/details/88699218" target="_blank" rel="noopener">直方图均衡化</a></p><p>所用函数应该遵顼一下几个限制</p><ul><li><p>变换函数$T(r) 是单增函数$——防止灰度反变换时出现人为缺陷</p></li><li><p>输出范围和输入范围相同 $0&lt;r&lt;L$，时候要求$&lt;0T(r)&lt;L$</p></li><li><p>正反函数都是一对一的（确保能够还原回去，如果遇到小数则选择合适的近似方法解决反变换问题）</p></li><li><p>$s = T(r) = (L-1)\int^r_0P_r(r)dr$，（L-1）为了使归一化后的像素展开到$[0,L-1]$</p></li></ul><h3 id="直方图匹配-规定化"><a href="#直方图匹配-规定化" class="headerlink" title="直方图匹配/规定化"></a>直方图匹配/规定化</h3><blockquote><p>直方图规定化（histogram specification）又称直方图匹配，是指使一幅图像的直方图变成规定形状的直方图而对图像进行变换的增强方法。就是通过一个灰度映像函数，将原灰度直方图改造成所希望的直方图。所以，直方图修正的关键就是灰度映像函数。</p><p>直方图规定化原理是对两个直方图都做均衡化，变成相同的归一化的均匀直方图。以此均匀直方图起到媒介作用，再对参考图像做均衡化的逆运算即可。直方图均衡化是直方图规定化的桥梁。<br>————————————————<br>版权声明：本文为CSDN博主「残月飞雪」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/majinlei121/article/details/46482615" target="_blank" rel="noopener">https://blog.csdn.net/majinlei121/article/details/46482615</a></p></blockquote><p>相当于现在已知源图像的分布律$pk(r)$，均衡直方图$s$ 【$s = (L-1)\int^r_0p_r(t)dt$】，想要变换称为的分布形式$p_z(z)$，把目标输出$z$变为均衡直方图的变换函数$G(z) = (L-1)\int^z_0p_z(t)dt$</p><p>这样，有以下几个公式：</p><p>$$s = (L-1)T(r) =\int^r_0p_r(t)dt$$</p><p>$$G(z) = (L-1)\int^z_0p_z(t)dt = s$$这里的<strong>$p_z(t)$是我们希望得到的像素分布情况，是已知的</strong></p><blockquote><p>均衡直方图相当于中间变量，起桥梁作用</p></blockquote><p>根据已知$z = G^{-1}[G(z)] = G^{-1}(s) = G^{-1}[T(r)]$</p><blockquote><p>数字图像处理第三章的例3.7通过实例演示了一遍求解方法                            </p></blockquote><p>实际情况中，其实不需要求出具体的反函数，可以用制表的方法进行像素值的映射</p><blockquote><p>根据变换函数G(z) 可以得到$z\to s$的映射，反过来用就可以了，需要单值函数才行，上面部分有说，要基本保证一一对应</p><p>在进行计算的时候需要进行四舍五入（灰度值是整数值），如果舍入以后不满足严格单增，那么按照惯例统一向下取整</p></blockquote><h3 id="局部直方图均衡化"><a href="#局部直方图均衡化" class="headerlink" title="局部直方图均衡化"></a>局部直方图均衡化</h3><p>类似直方图均衡化，只是把这种操作应用于图像的某个局部</p><p>书中所给的例子每次只更新中间点像素的值。</p><p><a href="https://blog.csdn.net/opencv_857310866/article/details/79592855" target="_blank" rel="noopener">局部直方图均衡化</a></p><h3 id="在图像增强中使用直方图统计"><a href="#在图像增强中使用直方图统计" class="headerlink" title="在图像增强中使用直方图统计"></a>在图像增强中使用直方图统计</h3><p>之前说过直图像的n阶矩定义为:</p><p>$$\mu_n(r) = \sum^{L-1}_{i=0}(r_i-m)^np(r_i)$$</p><ul><li>其中，$m$是$r$的均值（平均灰度）</li></ul><p>$$m = \sum^{L-1}_{i=0}r_ip(r_i) $$</p><p>二阶矩（灰度方差）很重要：</p><p>$$\sigma^2= \mu_2(r) = \sum^{L-1}_{i=0}(r_i-m)^2p(r_i)$$</p><blockquote><p>也可以使用直方图，直接使用</p><p>$m = \frac{1}{MN}\sum^{M-1}<em>{x=0}\sum^{N-1}</em>{y=0}f(x,y)$</p><p>和</p><p>$\sigma^2 = \frac{1}{MN}\sum^{M-1}<em>{x=0}\sum^{N-1}</em>{y=0}[f(x,y)-m]^2$</p></blockquote><ul><li><p>习惯上，方差和标准差计算方法一样（不非要获得无偏估计）</p></li><li><p>均值是平均灰度的度量</p></li><li><p>方差（标准差）是图像<strong>对比度</strong>的度量 </p></li></ul><h4 id="局部增强"><a href="#局部增强" class="headerlink" title="局部增强"></a>局部增强</h4><p>定义：对于任一点$(x,y)$，其以其为中心的邻域$S_{xy}$</p><p>可以计算任一点邻域的平均灰度$m_{s_{xy}}$和方差$\sigma_{S_{xy}}^2$</p><ul><li><p>如果要增强暗色区域，可以把该像素周围的平均灰度$m_{s_{xy}}$和全局平均灰度$m_G$比较，如果$$m_{s_{xy}}\le k_0m_g$$则考虑该<strong>点</strong>进行灰度变换（k为常数，小于1）</p></li><li><p>对于增强对比度，如法炮制，满足$k_1\sigma_{G}^2\le\sigma_{S_{xy}}^2\le k_2\sigma_{G}^2$的点作为候选点，这里面$k_1\sigma_G$是为了保证不让程序试图优化方差为0的区域（无用功，不会变的）</p><ul><li>如果是增强亮区需要$k_2&gt;1$增强亮区则相反。</li></ul></li><li><p>增强的方法可以直接采用$g(x,y) = Ef(x,y)$，其中E为一个常数，这样的方法，不需要特别的计算</p></li><li><p>关于k和E的取值，需要实际分析和尝试</p></li></ul><h1 id="空间滤波基础"><a href="#空间滤波基础" class="headerlink" title="空间滤波基础"></a>空间滤波基础</h1><h2 id="空间滤波机理"><a href="#空间滤波机理" class="headerlink" title="空间滤波机理"></a>空间滤波机理</h2><p>空间滤波器由两部分组成：</p><ol><li>一个邻域（通常是一个较小的矩形范围）</li><li>在领域上的操作组成</li></ol><p>滤波产生<strong>一个</strong>新的像素，新像素的坐标和邻域的中心点坐标相同。新像素的值是滤波操作的结果</p><p>滤波器中心访问每个像素图像后就生成了滤波后的图像</p><ul><li><p>线性滤波器：在图像像素上执行的是线性操作</p></li><li><blockquote><p>例如$g(x,y) = af(x-1,y-1)+bf(x-1,y)+cf(x,y-1)+df(x,y)$</p><p>更一般来来讲，使用和邻域size一样的系数矩阵$\boldsymbol W$，使$g(x,y) = \boldsymbol {W^T} S_{xy}$</p><p>即$g(x,y) = \sum^a_{s=-a}\sum^b_{t=-b}W(s,t)f(x+s,y+t)$，其中，系数矩阵$W$中心坐标为$(0,0)$</p><p>这意味着稀疏矩阵和邻域矩阵的长宽最好是<strong>奇数</strong>（不然没有中心像素），否则需要人为指定中心像素</p></blockquote></li><li><p>非线性滤波器：在图像像素上执行的是非线性操作</p></li></ul><h2 id="空间相关与卷积"><a href="#空间相关与卷积" class="headerlink" title="空间相关与卷积"></a>空间相关与卷积</h2><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>相关指的是滤波器模板平移过图像并计算每个位置乘积之和的处理（<strong>就是上面线性滤波器</strong>的操作）</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>和<strong>相关</strong>机理相似，不过是需要先把稀疏矩阵逆时针转180°，用这个翻转的矩阵进行余下操作</p><blockquote><p>参考阅读：<a href="https://my.oschina.net/datadev/blog/1859197" target="_blank" rel="noopener">为什么卷积要旋转180度</a></p></blockquote><p><strong>术语之间可能存在混淆或者乱用，不必纠结于文字游戏，应在实际应用中体会</strong></p><blockquote><p><a href="https://blog.csdn.net/saltriver/article/details/78883964" target="_blank" rel="noopener">空间滤波器是怎么来的</a></p></blockquote><p>滤波器矩阵最好是奇数的长宽（方便确认中心点），而且系数和最好为1（防止输出大于最大值）</p><ul><li>均值滤波——低通滤波器</li><li>中值滤波——非线性的——去除<strong>椒盐噪声</strong></li><li>最大/最小值滤波</li></ul><h2 id="锐化空间滤波器"><a href="#锐化空间滤波器" class="headerlink" title="锐化空间滤波器"></a>锐化空间滤波器</h2><p>用于突出灰度的过度部分（边缘或其他噪声）</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>对于采用的一阶微分方程由以下几点<strong>要求</strong></p><ol><li>在恒定灰度的区域为分支为<strong>零</strong></li><li>在灰度台阶或斜坡处的微分值为<strong>非零</strong></li><li><strong>沿</strong>斜坡的微分值为<strong>非零</strong></li></ol><p>同样，二阶微分方程要求和一阶<strong>相似</strong></p><ol><li>在恒定灰度的区域为分支为<strong>零</strong></li><li>在灰度台阶或斜坡<strong>起点</strong>处微分值<strong>非零</strong></li><li>沿斜坡的微分值为<strong>零</strong></li></ol><p>一维函数的一阶微分的基本定义为：</p><p>$$\frac{\part{x}}{\part x} = f(x+1)-f(x)$$</p><ul><li>二维情况考虑两个空间轴处理偏微分</li></ul><blockquote><p>这个公式的推导在第十章会讲到，先当作规定记下来再说</p></blockquote><p>二阶微分定义为如下差分：</p><p>$$\frac{\part^2f}{\part x^2} = f(x+1)+f(x-1)-2f(x)$$</p><h3 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="headerlink" title="拉普拉斯算子"></a>拉普拉斯算子</h3><p>这是一种各向同性算子（原图片先滤波再旋转和先旋转再滤波结果一样）】</p><blockquote><p>只适合于旋转近似90°倍数的时候</p></blockquote><p>一个二维图像的拉普拉斯算子定义如下：</p><p>$$\nabla^2f = \frac{\part^2f}{\part x^2}+\frac{\part^2f}{\part y^2}$$</p><p>因为任意微分都是线性操作，所以拉普拉斯变换也是一个<strong>线性算子</strong></p><p>其中，<strong>类似一维的情况</strong>，对于偏导有如下计算公式：</p><p>$$\frac{\part^2f}{\part x^2,y} = f(x+1,y)+f(x-1,y)-2f(x,y)$$</p><p>$$\frac{\part^2f}{\part y^2} = f(x,y+1)+f(x,y-1)-2f(x,y)$$</p><p>所以，拉普拉斯算子的公式可以表达为下面这种方式：</p><p>$$\nabla^2f = f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$</p><p>这个公式可以用之前的滤波模板来实现</p><p>拉普拉斯变换会突出显示灰度变化的部分，如果想要锐化图像，需要把锐化后的结果加到源图像上：</p><p>$$g(x,y) = f(x,y)+c[\nabla ^2f(x,y)]$$</p><h2 id="非锐化掩蔽和高提升滤波"><a href="#非锐化掩蔽和高提升滤波" class="headerlink" title="非锐化掩蔽和高提升滤波"></a>非锐化掩蔽和高提升滤波</h2><p>印刷出版社已经用了多年的图像锐化处理过程是<strong>从原图像减去一幅非锐化的模糊版本</strong></p><p>过程如下：</p><ol><li><strong>原图像</strong>和经过处理变的模<strong>糊原图像</strong></li><li>从原图像中减去模糊图像（产生的插值图像称为模板）</li><li>讲模板加到原图像上</li></ol><p>公式表示如下，$\bar f(x,y)$表示模糊后的原图像</p><p>首先得到一个模板</p><p>$$g(x,y)_{mask} = f(x,y)-\bar f(x,y)$$</p><p>然后，给模板一个权重，把模板加到原图像上</p><p>$$g(x,y) = f(x,y)+ k*g_{mask}(x,y)$$</p><ul><li>$k\ge0$</li><li>$k=1$为<strong>非锐化掩蔽</strong></li><li>$k&gt;1$称为<strong>高提升滤波</strong></li></ul><h3 id="使用一阶微分锐化（非线性）图像——梯度"><a href="#使用一阶微分锐化（非线性）图像——梯度" class="headerlink" title="使用一阶微分锐化（非线性）图像——梯度"></a>使用一阶微分锐化（非线性）图像——梯度</h3><p>图像处理中一阶微分是用梯度幅值实现的。对于函数$f(x,y)$，$f$在坐标$(x,y)$处的梯度定义为<strong>二维向量</strong>：</p><p>$$\nabla f \equiv grad(f) \equiv \begin{bmatrix} g_x\\g_y \end{bmatrix} \equiv \begin{bmatrix} \frac{\nabla f}{\nabla x}\\ \\ \frac{\nabla f}{\nabla y} \end{bmatrix}$$</p><blockquote><p>在第十章会更加深入讨论梯度，这里只对使用给梯度幅度值锐化图像感兴趣</p></blockquote><p>该向量具有重要的几何意义，它指出了在位置$(x,y)$处$f$变化率最大的方向</p><ul><li>向量$\nabla f$的幅值（长度）表示为$M(x,y)$，即</li></ul><p>$$M(x,y) = mag(\nabla f) = \sqrt{g^2_x+g^2_y}$$，它是函数在$(x,y)$点处梯度的值</p><ul><li>梯度向量的分量是线性算子，梯度向量的<strong>幅值不是线性算子</strong>（因为有平方开根号操作）</li><li>$\nabla f \equiv grad(f) \equiv \begin{bmatrix} g_x\\g_y \end{bmatrix} \equiv \begin{bmatrix} \frac{\nabla f}{\nabla x}\\ \\ \frac{\nabla f}{\nabla y} \end{bmatrix}$ <strong>不是旋转不变的</strong>(各向同性)，<strong>但是</strong>幅值<strong>是</strong>旋转不变的</li><li>在<strong>某些</strong>实践中，用绝对值来近似平方、平方根操作更适合于计算，即</li></ul><p>$$M(x,y) = |g_x|+|g_y|$$</p><blockquote><p>该操作保留了灰度的相对变化，但是通常<strong>丢失</strong>了各向同性的特性</p></blockquote><p>如果说定义滤波器覆盖范围内的图像用如下矩阵形式表示</p><p>$$\begin{bmatrix} z_1 \ z_2 \ z_3\\z_4 \ z_5 \ z_6 \\ z_7 \ z_8 \ z_9 \end{bmatrix}$$</p><p>那么之前提到的$g_x = z_9-z_5$，$g_y = z_8-z_6$</p><p>x,y这种操作可以分别用以下算子表示：</p><p>$\begin{bmatrix} -1\ 0 \\ 0\ 1\end{bmatrix}$和$\begin{bmatrix} 0\ -1 \\ 1\ 0\end{bmatrix}$</p><ul><li>这叫做<strong>罗伯特交叉梯度算子</strong></li></ul><p>但是由于偶数尺寸的模板很难实现，因为他们没有对称中心</p><p>我们感兴趣的最小模板是 $3*3$模板，他们可以有如下表示</p><p>$$g_x = \frac{\nabla f}{x}=(z_7+2z_8+z_9)-(z_1+z_2+z_3)$$</p><p>$$g_y = \frac{\nabla f}{y}=(z_3+2z_6+z_9)-(z_1+z_4+z_7)$$</p><p>用模板分别表示如下：</p><p>$\begin{bmatrix} -1 \ -2 \ -1\\0 \ \ 0 \ 0 \\ 1 \ 2 \ 1 \end{bmatrix}$和$\begin{bmatrix} -1 \ 0 \ 1\\ -2 \ 0 \ 2 \\ -1 \ 0 \ 1 \end{bmatrix}$</p><p>这种算子叫做<strong>Soble算子</strong>，系数和为零（说明在灰度相同的地方产生的响应为零）</p><blockquote><p>这写东西在第十章会继续深入，现在先了解以下</p></blockquote><h1 id="使用模糊技术进行灰度变换和空间滤波"><a href="#使用模糊技术进行灰度变换和空间滤波" class="headerlink" title="使用模糊技术进行灰度变换和空间滤波"></a>使用模糊技术进行灰度变换和空间滤波</h1><p>过去我们学习的集合中，某个东西是否在一个集合中只有<strong>明确</strong>的两种状态（在或不在），但是当我们讨论，<strong>由年轻人组成的集合</strong>这种问题的时候，<strong>很难确定一个确切的准则</strong>（比如说现在规定20岁及以下为年轻人，那么20岁零1秒的人就不是年轻人了吗）。</p><p>我们想要的应该是年轻和不年轻之间的逐渐过渡，需要一个<strong>非限制评价</strong>的函数，让我们可以讨论一个人的年轻程度。</p><p><a href="https://blog.csdn.net/wang2012010865/article/details/78106369" target="_blank" rel="noopener">模糊集合理论</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数字图像处理》第二章笔记</title>
      <link href="/2020/02/shu-zi-tu-xiang-chu-li-di-er-zhang-bi-ji/"/>
      <url>/2020/02/shu-zi-tu-xiang-chu-li-di-er-zhang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是《数字图像处理（第三版）》的学习笔记，方便日后回忆和查看</p><p>对于一些难懂的知识加入了一些自己的理解和其他讲的比较明白的博客的链接</p><h1 id="关于人眼"><a href="#关于人眼" class="headerlink" title="关于人眼"></a>关于人眼</h1><ul><li>人眼的的视觉系统不是工作在全频段的，每次我们看不同亮度的物体都需要眼睛调节灵敏度。这叫做<strong>亮度适应现象</strong>，同一时间眼睛能够辨别的亮度级别很小，对于当前给定的亮度人眼的灵敏度级别称作<strong>亮度适应级别</strong></li></ul><h1 id="图像的获取"><a href="#图像的获取" class="headerlink" title="图像的获取"></a>图像的获取</h1><p>常见的图像传感器的排列方式有以下几种</p><ul><li>成一维的条状平面传感器，给该传感器加上一个垂直的传动带，就可以一行一行的读取数据</li><li>只有一块传感器，通过X，Y方向的位移获取数据<ul><li>典型的是传感器放在一根杆上，杆连接在一个圆柱桶上（类似于滑动变阻器，只不过把滑头变成单独一个传感器），桶上贴着胶片。每次桶先转动然后传感器滑动读取x方向数据，以此来读取一行</li></ul></li><li>核磁共振那样的圆筒，扫描物体的断层信息，需要配合专门的算法生成图片</li><li>传感器阵列，平铺在平面上，比如摄像机的CCD阵列</li><li>传感器获取的主要就是电磁信号<ul><li>这些信号有的是被测物体反射回来的（比如摄像机拍摄的）</li><li>有些信号是穿过被观测物体打在传感器上的（比如X光片）</li></ul></li><li>传感器输出信号强度大小与照射到传感器上电磁信号的强度成正比</li></ul><h1 id="图像模型"><a href="#图像模型" class="headerlink" title="图像模型"></a>图像模型</h1><ul><li><p>现在大家都使用$f(x,y)$这样的二维函数来表示图像。</p></li><li><p>在空间坐标$(x,y)$处$f$的值或幅度是一个正的标量，其物理意义由图像源决定。</p><ul><li>如果图像由物理过程产生，其亮度值正比于物理源（如电磁波）所辐射的能量<ul><li>所以 $0&lt;f(x,y)&lt;\infty$ （一定是非零有限的）</li></ul></li></ul></li><li><p>函数$f(x,y)$可由两个分量来表征</p><ul><li><p>观察场景的里光源照射总量</p></li><li><p>场景中物体所反射的光照总量</p></li><li><p>这两个量被称为<strong>入射分量</strong>和<strong>反射分量</strong>，而且$f(x,y) = i(x,y)r(x,y)$</p><ul><li><p>分别表示为$i(x,y)$和$r(x,y)$</p><ul><li><p>$0&lt;i(x,y)&lt;\infty$</p></li><li><p>$0&lt;r(x,y)&lt;1$，由于是反射分量，0表示全吸收，1表示全反射，这个取决于被成像物体的性质</p></li><li><blockquote><p>平均来讲，晴朗白天太阳照在地面大概产生$90,000 lm/m^{2}$</p><p>有云的白天可能就下降到$10,000lm/m^2$</p><p>晴朗的夜晚，满月时照度约为$0.1lm/m^2$</p><p>商用办公室典型照度约为$1000lm/m^2$</p><p>下面是$r(x,y)$的典型值</p><p>黑天鹅绒为$0.01$</p><p>不锈钢为$0.65$</p><p>白墙为$0.80$</p><p>镀银金属为$0.90$</p><p>雪为$0.93$</p></blockquote></li></ul></li></ul></li><li><p>对于上面这条，如果是类似X光这样的透射，应该用<strong>透射系数</strong>代替<strong>反射函数</strong>$r(x,y)$</p></li></ul></li><li><p>令单色图像在任何坐标$(x_{0},y_{0})$处<strong>强度（灰度）</strong>（强度和灰度含义相同）表示为$$\ell = f(x_0,y_0)$$</p><ul><li>因为$f(x,y) = i(x,y)r(x,y)$里面$i,r$都有范围，所以$L_{min}\le\ell\le L_{max}$</li><li>理论上只要求$L_{min}$为正，$L_{max}$为有限值。<ul><li>实际上，因为$L_{min} = i_{min}r_{min}$和$L_{max} = i_{max}r_{max}$ 根据之前说的办公室平均照度$i$和反射值$r$，我们希望$L_{min}\approx 10$和$L_{max}\approx 1000$作为室内没有附加照明时的典型范围</li><li>区间$[L_{min},L_{max}]$称为灰度级（或者强度级）。实际情况下通常令该区间为$[0,L-1]$<ul><li>其中$\ell = 0$为灰色</li><li>$\ell = L-1$<strong>在灰度级中</strong>为白色</li><li>所有中间值是 从黑色到白色之间变化的灰度色调</li></ul></li></ul></li></ul></li></ul><h1 id="图像的取样和量化"><a href="#图像的取样和量化" class="headerlink" title="图像的取样和量化"></a>图像的取样和量化</h1><ul><li>取样需要离散化图片的灰度值和图像上连续的灰度值函数（书P30图2.1.6形象说明）<ul><li>每个点的灰度值按照就近原则对应到不同的灰度级（例子给了八个级别）</li></ul></li></ul><h1 id="图像的表示"><a href="#图像的表示" class="headerlink" title="图像的表示"></a>图像的表示</h1><ul><li>离散图像在任一$(x,y)$处的值记为$f(x,y)$<ul><li>$x = 0,1,2,…,M-1$，$y=0,1,2,…,N-1$</li><li>$f(0,1)$表示<strong>第一行第二个</strong>像素的值</li></ul></li><li>二维图像可由$x,y$轴和另外的$z$轴（高低代表灰度值）的三维图像表示（太复杂了，通常不用）</li><li>用显示器或打印机，每个像素点的灰度值与该点的$f$值成正比</li><li><strong>把$f(x,y)$表示为数值阵列</strong></li><li>使用矩阵表示数字图像及其像素$A = $ 一个矩阵<ul><li>$a_{ij} = f(x=i,y=j) = f(i,j)$</li><li>灰度级数通常取2的整数次幂，$L=2^k$ </li></ul></li><li>动态范围：一幅图片可能不会占用全部256 ($2^8$)级灰度，图片里面所有像素跨越的灰度值称为动态范围<ul><li>比如一幅图片很暗，它可能的动态范围可能只有 $[0,100]$ ，而不是全部$[0,256]$（256是因为现在主流每个像素用8bit表示，可以表示256级灰度）</li><li>上限取决于饱和度，下限取决于噪声</li></ul></li><li>对比度：图像中最高级灰度和最低级灰度的差成为对比度<ul><li>动态范围高对比度高，反之低动态范围的图片看起来很沉闷</li></ul></li><li>存储一幅图像所需bit $b = M<em>N</em>k$ （长乘宽乘用几个比特表示灰度级）</li></ul><h1 id="空间和灰度分辨率"><a href="#空间和灰度分辨率" class="headerlink" title="空间和灰度分辨率"></a>空间和灰度分辨率</h1><ul><li><p><strong>空间分辨率</strong>用来度量图像中最小可辨细节</p><ul><li>通常用单位距离的线对数和单位距离的点数（像素数）</li><li>美国的印刷品使用的单位：dpi 表示每英寸的点数</li><li><strong>空间分辨率</strong>需要对空间的<strong>单位</strong>有定义才有实际意义（不然单位距离到底是多少）</li></ul></li><li><p>不知道图像包含的空间维数，谈论图像的分辨率（比如说某图是1024*1024像素）是没有意义的。尺寸本身只用在比较图像容量时</p><ul><li>可以说拍摄情况相同时候高清相机比普通相机分辨细节的能力高</li></ul></li><li><p><strong>灰度分辨率</strong>指在灰度级中可分辨的最小变化</p><ul><li>指的是用于量化灰度的比特数，比如256级的图像具有8bit的灰度分辨率</li></ul></li><li><p>减少k值（灰度分辨率）会提高图像对比度</p><ul><li><blockquote><p>百度的解释：</p><p>对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围的大小就是所说的对比度的大小.<br>减少灰度一级,就是说,灰的再暗一些的意思,这样图像的层次与艳丽会提高一档.<br>方便的话,可以用photoshop 里的色阶,就一目了然了.</p></blockquote></li></ul></li></ul><h1 id="图像内插"><a href="#图像内插" class="headerlink" title="图像内插"></a>图像内插</h1><blockquote><p>内插是放大、收缩、旋转、几何校正等任务的基本工具</p><p>本质上内插是用已知的数据去估计未知的数据</p></blockquote><h2 id="放大的插值方法"><a href="#放大的插值方法" class="headerlink" title="放大的插值方法"></a>放大的插值方法</h2><ul><li><p>最邻近内插（P37）</p></li><li><p>双线性内插</p><ul><li><p>令$(x,y)$为我们想要赋值的位置，令$v(x,y)$表示灰度值。</p></li><li><p>$v(x,y) = ax+by+cxy+d$  </p></li><li><blockquote><p>由于具有$xy$项，这其实不是一种线性内插方法，但不知道为啥名字里有线性二字</p></blockquote></li><li><p>式子中的四个系数可用由点$(x,y)$的四个最邻近点写出的未知方程确定</p></li></ul></li><li><p>双三次内插法，包括16个最邻近点（最常用）</p></li></ul><h1 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h1><ul><li><p>相邻像素</p><ul><li>上下左右四个像素称为4邻域，用$N_4(P)$表示。</li><li>左上右上左下右下四个像素用$N_D(P)$表示</li><li>八个相邻像素称为8邻域，用$N_8(P)$表示</li></ul></li><li><p>邻接、连接和连通，这篇<a href="https://www.cnblogs.com/SilentCode/p/5352860.html" target="_blank" rel="noopener">博客</a>有讲</p><ul><li>闭合通路（连通的起点和终点一样）</li><li>连通集：只有一个连通分量的集合<strong>也可称作区域</strong></li></ul></li><li><p>如果两个区域（$R_i和R_j$）可以形成一个<strong>连通集</strong>，他们叫做<strong>邻接区域</strong>，不邻接的区域称为不连接区域</p><ul><li>四邻接：上下左右四个点</li><li>八邻接：上下左右加上四个角，这样的一圈（<strong>所以属于4邻接的一定属于8邻接</strong>，反过来不行）</li><li>M邻接：同时存在八邻接和四邻接时候优先用四邻接（<strong>消除二义性</strong>）</li><li><a href="https://www.cnblogs.com/qinguoyi/p/7601178.html" target="_blank" rel="noopener">m邻接 </a></li></ul></li><li><p>两点间距离，设两点$P(x,y)$和$Q(s,t)$</p><ul><li>欧氏距离$D_e = \sqrt{(x-s)^2+(y-t)^2}$</li><li>曼哈顿距离（城市街区距离）$D_4 = |x-s|+|y-t|$，$D_4 = 1$时为像素的四邻域</li><li>棋盘距离 $D_8 = max(|x-s|,|y-t|)$，$D_8 = 1$时为像素的八邻域</li><li>$D_4$和$D_8$距离与任何通路<strong>无关</strong>这俩距离只与坐标有关</li><li>$D_m$距离用两点间的最短通路定义（按照m邻接方式计算）</li></ul></li></ul><h1 id="线性操作与非线性操作"><a href="#线性操作与非线性操作" class="headerlink" title="线性操作与非线性操作"></a>线性操作与非线性操作</h1><ul><li>线性操作：给定一个算子$H$，应用于特定的输入图像$f(x,y)$，输出图像$g(x,y)$<ul><li>线性算子$H$满足$H[a_if_i(x,y)+a_jf_j(x,y)] = a_iH[f_i(x,.y)]+a_jf_j(x,y) = a_ig_i(x,y)+a_jg_j(x,y)$</li><li>两个性质<strong>加性和同质性</strong>，但我没有搜到相关信息，我觉得应该是可加性和齐次性</li></ul></li><li>非线性操作：不满足可加性和齐次性的。比如$max$操作</li></ul><h1 id="算数操作"><a href="#算数操作" class="headerlink" title="算数操作"></a>算数操作</h1><ul><li>相同size图片之间的加减乘除（<strong>注意都是对应元素之间的操作</strong>，就是Matlab里的点乘）</li><li>为了避免出现图像算术操作出现像素值$&lt;0$或者$&gt;255$的情况，对每幅图像进行如下操作<ul><li>$f_m = f-min(f)$</li><li>$f_s =  K[f_m/max(f_m+\delta)]$ 这样，像素值都在$[0,K]$之间，8bit图像就令K=255<ul><li>加$\delta$是为了防止出现除零的情况</li></ul></li><li>该方法可以用于 16bit或者更高比特的图像</li></ul></li></ul><h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><ul><li><p>和数学上的集合运算相同</p></li><li><p>集合里的元素是坐标$(x,y)$</p></li><li><p>默认集合里元素的灰度值是<strong>相同的</strong>（二值图像最适合）</p></li><li><p>灰度图像集合元素是三元的$(x,y,z)$，xy是坐标，z是灰度值</p><ul><li>集合$A = {(x,y,z)}$的补集$A^c = {(x,y,K-z)|(x,y,z)\in A}$<ul><li>$K = 2^k-1$，8bit的就是K = 255</li></ul></li><li>两个灰度集合的并集$$A\bigcup B = {max(a,b)|a\in A,b \in B}$$</li></ul></li><li><p>逻辑操作（适用于二值图像）</p><ul><li>和数学中逻辑操作相同</li><li>OR AND 也可以看作集合的操作</li></ul></li><li><p>模糊集合</p><ul><li>在第三章会讲</li></ul></li></ul><h1 id="空间操作"><a href="#空间操作" class="headerlink" title="空间操作"></a>空间操作</h1><p>分为以下几类</p><ol><li><p>单像素操作</p><ul><li>改变单个像素的灰度值</li></ul><p>$$s = T(z)$$</p><ul><li>z源像素灰度，s是变换之后像素灰度</li></ul></li><li><p>邻域操作</p><ul><li><p>令$S_{xy}$代表图像f中以任意一点$(x,y)$为中心的一个邻域的<strong>坐标集</strong></p></li><li><p>邻域处理再输出图像$g$中相同的坐标处生成一个相应的像素，生成值由输入坐标在$S_{xy}$内的像素经过操作决定（操作由你自己定义）</p></li><li><blockquote><p>比如取平均值操作$$g(x,y) = \frac{1}{mn}\sum_{(r,c)\in S_{xy}}f(r,c)$$</p></blockquote></li></ul></li><li><p>几何空间变换</p></li></ol><p>几何空间变换由两个基本操作组成 1）坐标的空间变换    2）灰度内插，即对空间变换后的像$素$赋灰度值</p><ul><li>坐标变换可由下式表示：$$(x,y) = T{(v,w)}$$<ul><li>$(v,w)$是原图像中的像素坐标，$(x,y)$是变换后图像中像素坐标、</li><li>比如$(x,y) = T{(v,w) = (v/2,w/2)}$表示在两个方向上把源图像缩小一半</li><li>最常用空间坐标变换：<strong>仿射变换</strong>；形式如下$$[x\space y\space 1] = [v\space w\space 1]\boldsymbol{A}=[x\space y\space 1]\begin{bmatrix}t_{11}&amp;t_{12}&amp;0 \\t_{21}&amp;t_{22}&amp;0\\t_{31}&amp;t_{32}&amp;1 \end{bmatrix}$$</li><li>上边的式子是<strong>前向映射</strong>，容易出现多个像素映射到同一点的情况，可以用<strong>反向映射</strong>解决$$(v,w) = \boldsymbol{T^{-1}}(x,y)$$</li></ul></li><li>估计变换函数：选取一定量的校准点（比如我取四个点），有一个参考图像，在两幅图像的相同位置进行标记<ul><li>假设变换方程 $x = c_1v+c_2w+c_3vw+c_4$， $y = c_5v+c_6w+c_7vw+c_8 $</li><li>带入四个点的坐标求出系数</li><li>带入系数求其他的点</li></ul></li></ul><h1 id="向量与矩阵的操作"><a href="#向量与矩阵的操作" class="headerlink" title="向量与矩阵的操作"></a>向量与矩阵的操作</h1><ul><li>对于RGB图像，可以把图像这样表示$$\boldsymbol z = \begin{bmatrix} z_1\\z_2\\z_3\end{bmatrix}$$</li><li>$z_1\space z_2 \space z_3$分别代表RGB层</li><li>可以用向量和矩阵的操作方法操作图片<ul><li>线性变换$w = A(z-a)$，A是m*n的矩阵，z和a是n*1的列向量</li><li>线性处理：$g = Hf+n$，f是输入图像，H是操作，n是噪声</li></ul></li></ul><h1 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h1><p>主要就是空间域和变换域的问题，<a href="https://blog.csdn.net/ice__snow/article/details/78633143" target="_blank" rel="noopener">这个博客讲的不错</a></p><h1 id="概率方法"><a href="#概率方法" class="headerlink" title="概率方法"></a>概率方法</h1><ul><li>统计某一灰度级出现的概率可估计为$p(z_k) = \frac{n_k}{MN}$<ul><li>$\sum^{L-1}_{k=0}p(z_k)=1$</li><li>方差$\sigma^2 = \sum^{L-1}_{k=0}(z_k-m)^2p(z_k)$</li><li>n阶矩$\mu_n(z) = \sum^{L-1}_{k=0}(z_k-m)^np(z_k)$</li></ul></li><li>均值和方差与图片的视觉特性有明显的直接关系，高阶矩更敏感<ul><li>比如三阶矩&gt;0表示灰度倾向于比均值高&lt;0说明灰度倾向于比均值低，0说明灰度近似相等的分布在均值附近</li></ul></li><li>概率方法在后面的图像处理中很有用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（四）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-si/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-si/</url>
      
        <content type="html"><![CDATA[<h1 id="计算器2-0"><a href="#计算器2-0" class="headerlink" title="计算器2.0"></a>计算器2.0</h1><p>上一篇所讲的计算器使用起来非常的麻烦，每次都要修改printf函数里的内容并且重新编译程序。</p><p>现在，让我们开始一步一步做出一个这样的计算器：</p><p><img src="https://img-blog.csdnimg.cn/20200213235721969.png" alt="有点意思"></p><h2 id="从窗口输入"><a href="#从窗口输入" class="headerlink" title="从窗口输入"></a>从窗口输入</h2><p>我们如何才能让程序读取到我们的输入呢？</p><p>这时候我们就需要用到另一个实用的函数：<strong>scanf()</strong></p><p>但是！还有一个问题我们需要解决： <strong>我们读取进来的数字放在哪?</strong></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>C语言中有个叫变量的东西可以存储我们的数据，它的定义方式很简单</p><p><code>数据类型 变量名</code>就可以定义一个变量，比如这就是一个名为 Trump的int型变量</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> Trump<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就是一个名为Donald的float类型变量</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> Donald<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="怎么使用变量呢？"><a href="#怎么使用变量呢？" class="headerlink" title="怎么使用变量呢？"></a>怎么使用变量呢？</h3><ul><li>首先，你可以在程序中为变量指定一个值，比如这样</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> Trump <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> Donald<span class="token punctuation">;</span>Donald <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>其次，我们可以利用scanf函数从控制台读取一个数字</li></ul><p><code>未完待续 2020年2月14日 22点49分</code></p><p>如果您有建议或者意见，欢迎在评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（三）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-san/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-san/</url>
      
        <content type="html"><![CDATA[<p>上一篇，我们讲了printf的基本用法，并写了一个简单的计算器。</p><p>还记得上一篇最后的<strong>任务</strong>吗？</p><blockquote><p>计算 3/2 的得数</p></blockquote><p>如果你的代码是这样的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那我们的程序会输出一个很奇怪的结果：<strong><em>1</em></strong></p><h1 id="为什么3-2会等于1？"><a href="#为什么3-2会等于1？" class="headerlink" title="为什么3/2会等于1？"></a>为什么3/2会等于1？</h1><p>要说明这个问题我们有必要先了解C语言是怎样存储和表示数字和字符的</p><h2 id="C语言基本数据类型"><a href="#C语言基本数据类型" class="headerlink" title="C语言基本数据类型"></a>C语言基本数据类型</h2><p>C语言有六种基本数据类型，他们分别是 short、long、int、float、double、char</p><p>在内存中，不同的类型占用不同的空间，short占2byte，int占4byte，long占4byte，float占2byte，double占8byte，char占1byte</p><blockquote><p>​    注：这个不绝对，可能会有所出入，应视具体情况而定</p></blockquote><h3 id="为什么引入数据类型"><a href="#为什么引入数据类型" class="headerlink" title="为什么引入数据类型"></a>为什么引入数据类型</h3><p><del>数据类型能帮助我们更好的管理计算机的内存，比如固体液体和气体都叫做物质，但是分类更好</del></p><blockquote><p>如果你实在想知道，那我推荐这篇博文 <a href="https://www.2cto.com/kf/201707/654323.html" target="_blank" rel="noopener">数据类型的本质</a></p><blockquote><p>不懂什么是变量？不要着急，本篇后面会说明清楚</p></blockquote><p>不知道为什么并不影响你学习C语言</p></blockquote><h3 id="数据类型相互转化"><a href="#数据类型相互转化" class="headerlink" title="数据类型相互转化"></a>数据类型相互转化</h3><p>C语言是允许不同类型的数据相互转化的，但因为C语言内部存储机制的问题，有些时候这种转化会导致你丢失一些东西</p><p>比如，int类型表示的是整数，如果你把一个小数转换成整数，我们只能得到这个小数的整数部分，它小数点后面的部分都被丢弃了</p><blockquote><p>在程序中使用 类型名称(数据) ，可以强制转换类型</p><p>例如 int(1.5)可以把1.5这个小数转为int类型（但是只能得到1，小数部分被自动丢掉了）</p></blockquote><h3 id="为什么我们的程序输出了整数？"><a href="#为什么我们的程序输出了整数？" class="headerlink" title="为什么我们的程序输出了整数？"></a>为什么我们的程序输出了整数？</h3><p>理论上来讲3/2应该得到 1.5，根据分类，这应该是一个float或者double类型的小数，但是我们的程序却输出了 1 这个int类型的整数</p><p>这是因为有些时候C语言会自动帮你完成类型转换这一过程</p><p>还记得我们的程序吗</p><p>因为$3/2$所使用的<strong>两个数都是int类型</strong>，C语言会自动把他们的计算结果转换成整数，导致我们小数点后面数据的丢失</p><h3 id="如果修正？"><a href="#如果修正？" class="headerlink" title="如果修正？"></a>如果修正？</h3><p>这里有两个方法修正我们的程序</p><ol><li>根据<a href="https://www.cnblogs.com/weiyouqing/p/9090542.html" target="_blank" rel="noopener">C语言中不同类型的数据转换规则</a> （可点击进入查看转换规则），我们可以把表达式改为$3.0/2$（或者$3/2.0$、$3.0/2.0$）这样C语言会把表达式的结果记float类型</li><li>通过强制类型转换，我们可以强制把3变为浮点数<code>float(3)</code>或者把2变为浮点数<code>float(2)</code>，得到<code>float(3)/2</code>【或者<code>3/float(2)</code>、<code>float(3)/float(2)</code>】来达到我们的目的</li></ol><blockquote><p>注意：<code>float(3/2)</code>是不可以的，因为计算机在算$3/2$的时候就已经进行了丢弃数据（小数点后面内容）的操作，被丢掉的内容是无法还原的</p></blockquote><p>也许你已经改完了程序，它现在看起来是这样的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如果这时候运行程序，我们还是无法得到正确的答案"><a href="#如果这时候运行程序，我们还是无法得到正确的答案" class="headerlink" title="如果这时候运行程序，我们还是无法得到正确的答案"></a>如果这时候运行程序，我们还是无法得到正确的答案</h4><p>还记得之前所讲的<strong>占位符</strong>吗，对于int类型的数据，我们可以通过在文字里加上%d给整数占个位子。但现在时代变了，要想为$1.5$这个浮点数占个位子我们需要用<code>%f​</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3/2 = %f"</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行一下</p><p><img src="https://img-blog.csdnimg.cn/20200212235021995.png" alt="还不错"></p><p>没有问题，我们程序输出了正确的结果</p><p>但你可能会有一点完美主义情结——<strong>能不能不要让这破程序输出这么多零？</strong></p><p>对于这一点其实printf()也给我们提供了设置输出格式的方法，具体可以看<a href="https://blog.csdn.net/qq_29874741/article/details/94626531" target="_blank" rel="noopener">C语言printf()输出格式大全</a>，<strong>自己动手尝试</strong>不同的输出方式才能更快的学会。</p><p>如果您有更好的意见或者建议，请在评论区留言，感谢！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MiniZinc学习笔记</title>
      <link href="/2020/02/minizinc-xue-xi-bi-ji/"/>
      <url>/2020/02/minizinc-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>最近在Coursera上学了 <a href="https://www.coursera.org/learn/lisan-youhua-jianmo-jichupian" target="_blank" rel="noopener">离散优化建模</a>，里面介绍了MiniZinc这个建模语言，个人觉得比较新奇</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul><li><p>MiniZinc 语句顺序不重要</p><ul><li>你可以先定义变量再写表达式，这不是一个需要编译或者逐句解释得语言</li><li>写的程序主要是为了给后端得求解器描述问题</li></ul><ul><li>关于变量<ul><li>MiniZinc变量类型主要分为两大类<ul><li>参数</li><li>决策变量</li></ul></li></ul></li></ul></li></ul><p>其中<strong>参数</strong>类似于其他语言中的<strong>常量</strong>，<strong>只能在程序开始的时候被赋值</strong>而且<strong>只能被赋值一次</strong></p><p><strong>决策变量</strong>相当于其他语言中普通的可变变量（类似于方程中的未知数）</p><p><img src="https://img-blog.csdnimg.cn/20200210125011804.png" alt="变量声明"></p><p>可以看到，MiniZinc对于变量声明方式也是比较特殊的，形式为<code>变量类型描述:变量名称</code></p><p>当然，这两个分类只是从<strong>变量是不是常量</strong>的角度划分的</p><p>MiniZinc像其他语言一样，支持整数、浮点，数组、字符串、枚举、集合等类型</p><p>比如生成一个大小为10的int类型数组</p><ul><li>1..10代表从1到10的一个<strong>整数序列</strong></li><li>数组统一用array[]表示，方括号里边写数组包含的下标，图里的数组可以访问的下标范围是1~10</li><li>数组的下标可以是任意的类型（文字什么的也都可以，类似于字典，不过只能一对一）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200210125104691.png" alt="声明一个下标为1~10的int类型数组"></p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>MiniZinc是建模语言，它的主要作用是求解数学模型，我们光定义变量是不够的，一个模型除了$x,y,z$这样的变量还有会有很多的<strong>约束</strong>，比如$x = y+1$、$x\ge5$、$z\in R$ 等等，那么这些约束要怎样表达出来呢？</p><p>以一个简单的约束问题来看</p><p>$$x\in[-1,10],x\in Z,y=-(x-1)^2$$</p><p>求$max(y)$</p><p>很明显，这个问题的意思就是，x可以取从-1到10的整数（也就是x可以等于-1,0,1,2,3,4,5,6,7,8,9,10）$y=-(x-1)^2$ ，求一下 $y$ 的最大值</p><p>这个问题很简单，但足够用来说明MiniZinc的语法</p><p>首先我们定义变量x和y</p><pre><code>var int: x; %定义整数变量xvar int: y; %定义整数变量y</code></pre><p>接着，我们给x限定取值范围，并输入表达式 $y=-(x-1)^2$ ，这时候就需要用到我们的<strong>约束关键字</strong>了</p><pre><code>var int: x; %定义整数变量xvar int: y; %定义整数变量yconstraint x&gt;=-1;constraint x&lt;=10;constraint y = -((x-1)^2) %必须要加上括号，不然会出问题</code></pre><p>这里面，<strong>constraint</strong> 之后放上就是我们模型的约束</p><p>最后，我们要求最大值，使用 <strong>solve</strong> 语句</p><pre><code>var int: x; %定义整数变量xvar int: y; %定义整数变量yconstraint x&gt;=-1;constraint x&lt;=10;constraint y = -((x-1)^2) %必须要加上括号，不然会出问题solve maximize y;</code></pre><p><strong>solve</strong> 后面紧跟着我们想要的目标，maximize是MiniZinc内置的关键字，表示求最大值（最小值是minimize），后面接上y，表示求y这个变量的最大值</p><p>运行这个脚本，我们可以得到</p><blockquote><p>x=1;</p><p>y=0;</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对于这个脚本，我们可以进行一些优化，让脚本行数更少一些</p><blockquote><p>注意：一般来讲，模型的描述越紧凑，MiniZinc求解的速度越快，尤其是聚类等问题，越少使用constraint，求解速度越快</p></blockquote><p>首先，我们可以在变量定义的时候就限制x的取值范围</p><pre><code>var -1..10: x; %x可以是从-1到10的任意整数</code></pre><p>其次，我们可以在变量定义的时候就给y赋值</p><pre class="line-numbers language-\"><code class="language-\">var int: y = -((x-1)^2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们的脚本就优化成了这样</p><pre><code>var -1..10: x; var int: y=-((x-1)^2);solve maximize y;</code></pre><p>理论上，这样的模型具有更快的求解速度（不绝对，视求解器而定）</p><h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>我们发现，这个脚本运行以后只输出x的值，不输出y了</p><p>对此，我们需要指定脚本的输出格式。</p><p>语法如下</p><pre><code>output &lt;字符串列表&gt;;</code></pre><p>与C语言类似，字符串写在<kbd>"</kbd> <kbd>"</kbd>里面，也支持\t \n等转义符</p><p>对于如果要输出变量可以采用<strong>(变量名)</strong>的方式或者 <strong>“字符串”++show(变量名)</strong>的方式</p><blockquote><p>注意：MIniZinc里两个字符串之间用两个加号连接</p></blockquote><p>一般来讲，我们这样书写输出语句</p><pre><code>output [&quot;1+1 = &quot; ++ show(1+1)]; %写在方括号里，show函数把变量或者其他类型转为字符串类型</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MiniZinc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（二）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-er/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-er/</url>
      
        <content type="html"><![CDATA[<h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h1><blockquote><p>回顾：<br>在上一篇的教程中，我们了解了printf的功能和它的由来</p></blockquote><p>还记得我们上一篇的代码吗？</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，把<code>printf(&quot;Hello World&quot;);</code>改成<code>printf(&quot;1+1 = %d&quot;,1+1);</code><br>我们得到以下代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1+1 = %d"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，运行一下，来看看结果如何</p><p><img src="https://img-blog.csdnimg.cn/20200209215420217.png" alt="真理"><br>果然，如你料想的一样，这个程序输出了<strong>1+1 = 2</strong>这个真理</p><p>那么，让我们端详一下<strong>printf()括号里面</strong>的变化：</p><ul><li>等号后面有奇怪的 <strong>%d</strong></li><li>双引号外面多了个逗号，后面又有一个1+1</li></ul><p><code>如图所示</code><br><img src="https://img-blog.csdnimg.cn/20200209221042996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="代码的变化"><br>双引号里面的 <strong>%d</strong> 叫做<strong>占位符</strong>，顾名思义，<strong>%d</strong>只是替一个整数值占了个位置，在程序运行时后面<strong>1+1</strong>这个式子的结果会替换掉 <strong>%d</strong><br><img src="https://img-blog.csdnimg.cn/20200209221506654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMDA1NTg=,size_16,color_FFFFFF,t_70" alt="替换方式"></p><blockquote><p>注意：printf的使用要遵照这样的格式：<strong>printf(“格式化字符串”, 参数1, 参数2, … ,参数n)；</strong><br>其中<strong>格式化字符串</strong>是你想要输出的主要内容，参数1..n为放在文中占位符的东西，参数之间用<strong>英文逗号</strong>隔开</p></blockquote><p>C语言还支持很多其他的占位符，如表所示，在之后的章节中，我们随用随说</p><table><thead><tr><th>占位符</th><th>占的位置代表类型</th></tr></thead><tbody><tr><td>%c</td><td>一个字符</td></tr><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%i</td><td>十进制、八进制、十六进制整数</td></tr><tr><td>%o</td><td>八进制整数</td></tr><tr><td>%x</td><td>十六进制整数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%f,%F,%e,%E,%g,%G</td><td>实数，可以是小数或者指数形式</td></tr><tr><td>%u</td><td>无符号十进制整数</td></tr><tr><td>%%</td><td>百分号</td></tr></tbody></table><p>在上面简单计算器的基础上，我们可以做一些小的扩展，比如，我希望计算下面算式的结果</p><table><thead><tr><th>2+2</th><th>2*3</th><th>4➗2</th></tr></thead></table><p>根据我们上面所讲，我们可以可以尝试拼凑出下面的一行代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2+2 = %d, 2*3 = %d, 3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：C语言的除号是<kbd>/</kbd>，而不是➗</p></blockquote><p>把它替换掉原来的printf我们得到以下程序</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2+2 = %d, 2*3 = %d, 3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来运行一下这个程序，看一看结果<br><img src="https://img-blog.csdnimg.cn/20200209223323912.png" alt="倒是没算错"><br>当然，其实我们更希望程序能像下面这样分行输出</p><blockquote><p>2+2 = 4,<br>2*3 = 6,<br>4/2 = 2</p></blockquote><p>但经过之前的实践，我们知道不论是用多个printf还是加上回车我们都无法成功换行。</p><h1 id="如何换行？"><a href="#如何换行？" class="headerlink" title="如何换行？"></a>如何换行？</h1><p>这时候，就需要用到一个叫做转义符的东西 <strong>“\n”</strong>，我们把之前的代码改成这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2+2 = %d,\n 2*3 = %d,\n 3/2 = %d"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会有效果吗？运行一下再说</p><p><img src="https://img-blog.csdnimg.cn/20200209223958979.png" alt="商业级排版"></p><p><strong>完美！</strong> 我们成功实现了让文字换行输出</p><p>别着急，还有一个新的问题</p><h1 id="什么是转义符？"><a href="#什么是转义符？" class="headerlink" title="什么是转义符？"></a>什么是转义符？</h1><p>简单来说就是我们把键盘上一些特殊的功能键（回车、制表符、退格……）设置成了一些指令，具体来讲，C语言支持以下转义符</p><table><thead><tr><th align="center">转义字符</th><th align="left">意义</th></tr></thead><tbody><tr><td align="center">\a</td><td align="left">响铃(BEL)</td></tr><tr><td align="center">\b</td><td align="left">退格(BS) ，将当前位置移到前一列</td></tr><tr><td align="center">\f</td><td align="left">换页(FF)，将当前位置移到下页开头</td></tr><tr><td align="center">\n</td><td align="left">换行(LF) ，将当前位置移到下一行开头</td></tr><tr><td align="center">\r</td><td align="left">回车(CR) ，将当前位置移到本行开头</td></tr><tr><td align="center">\t</td><td align="left">水平制表(HT)</td></tr><tr><td align="center">\v</td><td align="left">垂直制表(VT)</td></tr><tr><td align="center">\\’</td><td align="left">单引号</td></tr><tr><td align="center">\\”</td><td align="left">双引号</td></tr><tr><td align="center">\\\</td><td align="left">反斜杠</td></tr></tbody></table><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>请尝试用本章所讲计算 3/2 的结果</p><p>如果您有建议或者意见，欢迎在评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础教程（一）</title>
      <link href="/2020/02/c-yu-yan-ji-chu-jiao-cheng-yi/"/>
      <url>/2020/02/c-yu-yan-ji-chu-jiao-cheng-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="关于编程环境"><a href="#关于编程环境" class="headerlink" title="关于编程环境"></a>关于编程环境</h1><p>网络上有很多C语言编程环境的配置教程，也有很多开箱即用的安装包，请大家自行摸索，对于学习来讲，微软的Visual Studio足以满足我们的需求。</p><p><code>注意：由于编译器不同，Visual Studio并不完全适合C语言开发，如果您的学校有具体的环境要求，还请遵照学校要求</code></p><blockquote><p>对于刚刚接触编程的新手，我本人<strong>不提倡</strong>直接在Linux环境编程（即使这样很装逼），也<strong>不提倡</strong>使用文本编辑器结合控制台指令编译的方式进行学习！</p></blockquote><h1 id="开篇：Hello-World"><a href="#开篇：Hello-World" class="headerlink" title="开篇：Hello World"></a>开篇：Hello World</h1><p>首先，请新建一个空白的文件，重命名为 Hello World.c<br>把下面的东西复制粘贴到你新建的文件里面</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用您ide的编译运行功能（一般快捷键为<kbd>F5</kbd>)，您应当能看到一个黑色窗口弹出，并显示如下文字<br><img src="https://img-blog.csdnimg.cn/2020020722072394.png" alt="你好，世界！"></p><p><code>没有显示，或者黑窗一闪而过？，请尝试以下代码！</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>我想现在你一定有很多的疑问，但请不要着急，接下来我会进行说明。</code></p><h2 id="关于printf-“Hello-World”"><a href="#关于printf-“Hello-World”" class="headerlink" title="关于printf(“Hello World”)"></a>关于printf(“Hello World”)</h2><p><strong>究竟是什么东西让我的屏幕上显示出了 Hello World ?</strong></p><p>如果你把程序进行修改，比如把双引号里面的 <em>Hello World</em> 换成 <em>您吃了吗？</em> ，你会发现程序的运行结果也随之改变。<br><strong>e.g.</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>换为</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更进一步，如果你把 <strong>printf(“您吃了吗？”);</strong> 多复制几次，比如这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您吃了吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，请保持您新输入的东西在 <strong>int main(){ </strong> 和 <strong>return 0</strong>之间，稍后我会说明原因</p></blockquote><p>再次运行程序，你会发现你的屏幕上出现了一连串来自电脑的亲切的问候.<br><img src="https://img-blog.csdnimg.cn/20200207223123544.png" alt="冬日里温暖的问候"></p><blockquote><p>当然，作为完美主义者，您可能并 <strong>不喜欢这些话挤在一行</strong> ，可如果你尝试在句子里添加回车，你会发现加再多的回车也<strong>没有效果</strong>，甚至会导致程序无法运行，请不要着急，稍后我会说明原因</p></blockquote><p>这时候，相信您已经猜到了，就是这个看起来很奇怪的 <strong>printf(“ “);</strong> 把我们投喂给它的东西放到了屏幕上</p><h3 id="printf-是什么，它是从哪来的？"><a href="#printf-是什么，它是从哪来的？" class="headerlink" title="printf()是什么，它是从哪来的？"></a>printf()是什么，它是从哪来的？</h3><p>还记得我们最开始的程序吗</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意看这一句</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>#include</strong>是什么？<br>如果我们说的专业一点就是</p><blockquote><p>#include 是C/C++中包含头文件命令，用于将指定头文件嵌入源文件中。<br>……来自百度百科</p></blockquote><p>当然，这样的解释对于新手来讲未免看的有些云里雾里。<br>为了深刻理解，我们不妨<strong>先删掉</strong>代码中的<code>#include &lt;stdio.h&gt;</code></p><p>我们的程序就变成了这样</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//Hello world.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，如果我们重新编译运行程序，我们只会得到一条错误信息：<code>“printf”: 找不到标识符</code></p><p><code>注意：不同的ide对于错误提示可能有所不同</code></p><p>发生了什么？我们的编译器找不到<strong>printf</strong>了</p><p>那么是不是C语言本身并不包含<strong>printf</strong>这个东西，<strong>它其实是存在于其他人写好的文件当中</strong>呢?</p><p>确实是这样，C语言本身不能直接在屏幕上显示文字，<strong>前辈们</strong>为了方便后人编写程序，已经把输出文字的功能写好，并装在了<strong>stdio.h</strong>文件里头</p><p>而 <code>#include&lt;stdio.h&gt;</code> 就是告诉你的编译器把<code>stdio.h</code>这个文件的内容加载到你的程序里面，让你能直接使用前辈的智慧结晶</p><p><code>注意：stdio.h 里并不包含printf的完整实现，之后我会说明清楚</code></p><p>这里面，<strong>前辈写的程序</strong>被<strong>包装</strong>成了<strong>函数</strong>，<strong>函数</strong>有个<strong>名字</strong>叫做<strong>printf</strong></p><p><strong>什么是函数？</strong>，这里我不做过多解释，你完全可以认为<strong>函数就是</strong>一个黑盒子、一个<strong>自动炒菜锅</strong>，你把<strong>菜</strong>放<strong>进括号</strong>，<strong>他给你炒出你要的菜</strong></p><blockquote><p>不懂什么是 <strong>函数</strong> ？ 不要着急，之后我会花一章来慢慢说明</p></blockquote><p>现在，我们知道，<strong>printf</strong>来自<strong>stdio.h</strong>（全称 standard input &amp; output 即标准输入输出）这个文件，它由前辈们编写，为了方便我们编写其他的C程序。</p><p>如果您有建议或者意见，欢迎在评论区留言！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
